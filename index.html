<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawerz Beta 3</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.0/dist/ffmpeg.min.js"></script>
</head>
<body class="bg-gray-900 text-white flex flex-col h-screen overflow-hidden">
    <style>
        /* Base styles */
        body, html {
            font-family: 'Montserrat', sans-serif !important; 
            overscroll-behavior: none;
            background-color: #111827; 
            color: #e5e7eb; 
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

     
        .header {
            background-color: #1f2937; 
            padding: 0.75rem 1rem; 
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); 
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #374151; 
            flex-shrink: 0; 
            z-index: 20; 
        }

        .header-title {
            font-size: 1.25rem; 
            font-weight: 700; 
            color: #d1d5db; 
            font-family: 'Montserrat', sans-serif;
        }

        .header-buttons {
            display: flex;
            gap: 0.5rem; 
            align-items: center;
        }
        .control-panel-toggle { 
            display: none; 
            background: none;
            border: none;
            color: #9ca3af;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            font-family: 'Montserrat', sans-serif;
        }


        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden; 
            position: relative; 
        }

        .canvas-container {
            flex: 1;
            padding: 0.5rem; 
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #374151; 
            overflow: hidden; 
            position: relative; 
        }

        #drawingCanvas {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
            max-width: 100%;
            max-height: 100%;
            border: 1px solid #4b5563; 
        }


        .control-panel {
            width: 24rem; 
            background-color: #111827; 
            padding: 1rem; 
            box-shadow: -5px 0 15px -3px rgba(0, 0, 0, 0.1); 
            display: flex;
            flex-direction: column;
            gap: 1.25rem; 
            border-left: 1px solid #374151; 
            max-height: 100%; 
            overflow-y: auto; 
            transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out; 
            z-index: 10; 
            font-family: 'Montserrat', sans-serif;
        }

        .section { display: flex; flex-direction: column; gap: 0.75rem; }
        .section-title {
            font-size: 1.1rem; 
            font-weight: 600; 
            color: #9ca3af; 
            border-bottom: 1px solid #374151; 
            padding-bottom: 0.4rem;
            margin-bottom: 0.2rem; 
            font-family: 'Montserrat', sans-serif;
        }

        .tools-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 0.5rem; }

        .btn {
            display: inline-flex; 
            align-items: center;
            justify-content: center;
            gap: 0.5rem; 
            padding: 0.5rem 0.75rem; 
            border-radius: 0.375rem; 
            font-weight: 500; 
            transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.15s ease-in-out;
            cursor: pointer;
            border: 1px solid #4b5563; 
            font-size: 0.8rem; 
            color: #d1d5db; 
            background-color: #374151; 
            white-space: nowrap; 
            font-family: 'Montserrat', sans-serif !important; 
        }
        .btn i { font-size: 0.9em; } 


        .btn:hover:not(:disabled) {
            transform: translateY(-1px); 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            background-color: #4b5563; 
            border-color: #6b7280;
        }
        .btn:active:not(:disabled) {
            transform: translateY(0px);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
            background-color: #2d3748; 
        }
        .btn.active-tool, .btn.active-layer-control { 
            background-color: #2563eb !important; 
            color: white !important;
            border-color: #3b82f6 !important; 
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); 
        }
        .btn.active-tool:hover, .btn.active-layer-control:hover { background-color: #1d4ed8 !important; }
        .btn-primary { background-color: #3b82f6; color: white; border-color: #3b82f6; }
        .btn-primary:hover:not(:disabled) { background-color: #2563eb; border-color: #2563eb;}
        .btn-primary:active:not(:disabled) { background-color: #1d4ed8; }
        .btn-danger { background-color: #ef4444; color: white; border-color: #ef4444; }
        .btn-danger:hover:not(:disabled) { background-color: #dc2626; border-color: #dc2626; }
        .btn-danger:active:not(:disabled) { background-color: #b91c1c; }
        .btn:disabled, .btn.btn-disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
        label.btn { display: inline-flex; }
        #loadInput { display: none; }

        .form-group { display: flex; flex-direction: column; gap: 0.4rem; }
        .form-label { font-size: 0.8rem; font-weight: 500; color: #9ca3af; font-family: 'Montserrat', sans-serif; }
        .form-label span { color: #e5e7eb; } 
        input[type="range"] { width: 100%; height: 0.5rem; background-color: #374151; border-radius: 9999px; appearance: none; cursor: pointer; transition: background-color 0.15s ease-in-out; }
        input[type="range"]:hover { background-color: #4b5563; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 1rem; height: 1rem; background: #3b82f6; border-radius: 50%; cursor: pointer; border: 2px solid white; transition: background-color 0.15s ease-in-out, transform 0.1s ease-in-out; }
        input[type="range"]::-moz-range-thumb { width: 0.8rem; height: 0.8rem; background: #3b82f6; border-radius: 50%; cursor: pointer; border: 2px solid white; transition: background-color 0.15s ease-in-out, transform 0.1s ease-in-out; }
        input[type="range"]:hover::-webkit-slider-thumb { background: #2563eb; transform: scale(1.1); }
        input[type="range"]:hover::-moz-range-thumb { background: #2563eb; transform: scale(1.1); }
        input[type="color"] { width: 100%; height: 2.25rem; padding: 0.125rem; background-color: #374151; border: 1px solid #4b5563; border-radius: 0.375rem; cursor: pointer; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 0.25rem; }
        input[type="color"]::-moz-color-swatch { border: none; border-radius: 0.25rem; }

        .footer { padding: 0.75rem; background-color: #1f2937; color: #6b7280; text-align: center; font-size: 0.75rem; border-top: 1px solid #374151; flex-shrink: 0; font-family: 'Montserrat', sans-serif;}
        .hidden { display: none !important; }
        #loadingIndicator { position: fixed; inset: 0; background-color: rgba(17, 24, 39, 0.8); display: flex; justify-content: center; align-items: center; z-index: 100; }
        .loading-content { display: flex; flex-direction: column; align-items: center; gap: 1rem; background-color: #1f2937; padding: 2rem; border-radius: 0.5rem; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); color: #e5e7eb; }
        .loading-content span { font-family: 'Montserrat', sans-serif; } 
        .spinner { border: 4px solid #4b5563; border-top-color: #3b82f6; border-radius: 50%; width: 2.5rem; height: 2.5rem; animation: spin 0.8s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .modal { position: fixed; inset: 0; background-color: rgba(17, 24, 39, 0.8); display: flex; justify-content: center; align-items: center; z-index: 100; padding: 1rem; }
        .modal-content { background-color: #1f2937; color: #e5e7eb; padding: 1.5rem 2rem; border-radius: 0.5rem; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); max-width: 36rem; width: 100%; text-align: left; display: flex; flex-direction: column; gap: 1rem; font-family: 'Montserrat', sans-serif;}
        .modal-title { font-size: 1.25rem; font-weight: 600; color: white; }
        .modal-message { color: #d1d5db; font-size: 0.925rem; line-height: 1.6; }
        .modal-message ul { list-style-type: disc; padding-left: 1.5rem; margin-top: 0.5rem; }
        .modal-message code { background-color: #374151; padding: 0.1em 0.4em; border-radius: 0.25rem; font-size: 0.85em; }
        .modal-button-container { display: flex; justify-content: flex-end; margin-top: 1rem; }
        .modal-button { background-color: #3b82f6; color: white; font-weight: 500; padding: 0.625rem 1.25rem; border-radius: 0.375rem; border: 1px solid #3b82f6; font-family: 'Montserrat', sans-serif !important; }
        .modal-button:hover { background-color: #2563eb; border-color: #2563eb; }

        .layers-list { display: flex; flex-direction: column; gap: 0.5rem; max-height: 180px; overflow-y: auto; border: 1px solid #374151; border-radius: 0.375rem; padding: 0.5rem; }
        .layer-item { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; border-radius: 0.25rem; background-color: #1f2937; border: 1px solid #374151; cursor: pointer; transition: background-color 0.15s ease, border-color 0.15s ease; }
        .layer-item:hover { background-color: #2d3748; }
        .layer-item.active-layer { background-color: #3b82f6; border-color: #2563eb; color: white; }
        .layer-item.active-layer .layer-name, .layer-item.active-layer .layer-opacity-value { color: white; }
        .layer-name { flex-grow: 1; font-size: 0.8rem; color: #d1d5db; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .layer-name-input { flex-grow: 1; font-size: 0.8rem; background-color: #374151; color: white; border: 1px solid #4b5563; border-radius: 0.25rem; padding: 0.25rem 0.5rem; font-family: 'Montserrat', sans-serif; }
        .layer-controls { display: flex; gap: 0.25rem; }
        .layer-controls .btn { padding: 0.25rem 0.375rem; font-size: 0.7rem; } 
        .layer-opacity-control { display: flex; flex-direction: column; gap: 0.25rem; margin-top: 0.5rem; }
        .layer-opacity-control input[type="range"] { height: 0.4rem; }
        .layer-opacity-control .form-label { font-size: 0.8rem; }
        .layer-actions { display: flex; gap: 0.5rem; margin-top: 0.5rem; flex-wrap: wrap; }
        .layer-actions .btn { flex-grow: 1; min-width: 80px; } 

        ::-webkit-scrollbar { width: 0.5rem; height: 0.5rem; } 
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 0.25rem; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        @media (max-width: 900px) { 
            .header-title { font-size: 1.1rem; }
            .header-buttons .btn span { display: none; } 
            .header-buttons .btn i { margin-right: 0; } 
            .header-buttons .btn { padding: 0.5rem; } 


            .control-panel {
                position: absolute;
                right: 0;
                top: 0;
                bottom: 0;
                transform: translateX(100%); 
                border-left: 1px solid #374151;
                box-shadow: -2px 0 10px rgba(0,0,0,0.3); 
                width: 280px; 
            }
            .control-panel.open {
                transform: translateX(0);
            }
            .control-panel-toggle {
                display: block; 
            }
        }
         @media (max-width: 480px) { 
            .header-buttons { gap: 0.25rem; }
            .header-buttons .btn { padding: 0.4rem; font-size: 0.7rem; }
            .header-buttons .btn i { font-size: 0.8em; }
            .control-panel { width: calc(100% - 40px); max-width: 280px; } 
            .section-title { font-size: 1rem; }
            .form-label { font-size: 0.75rem; }
            .layer-name, .layer-name-input { font-size: 0.75rem; }
         }
    </style>

    <header class="header">
        <h1 class="header-title">Drawerz Beta 3</h1>
        <div class="header-buttons">
            <button id="saveBtn" class="btn" title="Save (Ctrl + S)"><i class="fas fa-save"></i> <span>Save</span></button>
            <label for="loadInput" class="btn" title="Load (Ctrl + O)"><i class="fas fa-folder-open"></i> <span>Load</span></label>
            <input type="file" id="loadInput" accept=".drz">
            <button id="exportMp4Btn" class="btn btn-primary" title="Export MP4 (Ctrl + E)"><i class="fas fa-file-video"></i> <span>Export MP4</span></button>
            <button id="clearActiveLayerBtn" class="btn btn-danger" title="Clear Active Layer"><i class="fas fa-eraser"></i> <span>Clear Layer</span></button>
            <button id="clearAllLayersBtn" class="btn btn-danger" title="Clear All Layers (Ctrl + Shift + Delete)"><i class="fas fa-bomb"></i> <span>Clear All</span></button>
            <button id="undoBtn" class="btn" title="Undo (Ctrl + Z)"><i class="fas fa-undo"></i></button>
            <button id="redoBtn" class="btn" title="Redo (Ctrl + Y)"><i class="fas fa-redo"></i></button>
        </div>
        <button id="controlPanelToggle" class="control-panel-toggle"><i class="fas fa-bars"></i></button>
    </header>

    <div class="main-content">
        <div class="canvas-container">
            <canvas id="drawingCanvas"></canvas>
        </div>

        <aside id="controlPanel" class="control-panel">
            <div class="section">
                <h2 class="section-title">Drawing Tools</h2>
                <div class="tools-grid">
                    <button id="penTool" class="btn active-tool" title="Pen Tool (P)"><i class="fas fa-pen"></i> Pen</button>
                    <button id="eraserTool" class="btn" title="Eraser Tool (E)"><i class="fas fa-eraser"></i> Eraser</button>
                </div>
                <div class="form-group">
                    <label for="strokeSize" class="form-label">Stroke Size: <span id="strokeSizeValue">10</span>px</label>
                    <input type="range" id="strokeSize" min="1" max="100" value="10">
                </div>
                <div class="form-group">
                    <label for="strokeColor" class="form-label">Stroke Color</label>
                    <input type="color" id="strokeColor" value="#000000">
                </div>
            </div>
            
            <div class="section" id="layersSection">
                <h2 class="section-title">Layers</h2>
                <div id="layersList" class="layers-list"></div>
                <div class="layer-actions">
                    <button id="addLayerBtn" class="btn btn-primary" title="Add New Layer"><i class="fas fa-plus-circle"></i> Add Layer</button>
                </div>
                <div id="selectedLayerOpacityControl" class="form-group hidden">
                    <label for="layerOpacity" class="form-label">Layer Opacity: <span id="layerOpacityValue">100</span>%</label>
                    <input type="range" id="layerOpacity" min="0" max="100" value="100">
                </div>
            </div>

            <div class="section">
                <h2 class="section-title">Animation Effects (Active Layer)</h2>
                <div class="form-group">
                    <label for="wiggleIntensity" class="form-label">Wiggle Intensity: <span id="wiggleIntensityValue">0</span></label>
                    <input type="range" id="wiggleIntensity" min="0" max="20" value="0" step="0.5">
                </div>
                <div class="form-group"> 
                    <label for="breathingStroke" class="form-label">Breathing Stroke: <span id="breathingStrokeValue">0</span></label>
                    <input type="range" id="breathingStroke" min="0" max="20" value="0" step="1">
                </div>
                <div class="form-group">
                    <label for="shakeIntensity" class="form-label">Shake Intensity: <span id="shakeIntensityValue">0</span></label>
                    <input type="range" id="shakeIntensity" min="0" max="10" value="0" step="0.5">
                </div>
                <div class="form-group">
                    <label for="animationSpeed" class="form-label">Animation Speed: <span id="animationSpeedValue">1</span>x</label>
                    <input type="range" id="animationSpeed" min="0.1" max="5" value="1" step="0.1">
                </div>
            </div>
        </aside>
    </div>

    <div id="messageModal" class="modal hidden">
        <div class="modal-content">
            <h2 id="modalTitle" class="modal-title">Notification</h2>
            <p id="modalMessage" class="modal-message">This is a message.</p>
            <div class="modal-button-container">
                <button id="modalCloseBtn" class="btn modal-button">Close</button>
            </div>
        </div>
    </div>

    <div id="loadingIndicator" class="loadingIndicator hidden">
        <div class="loading-content">
            <div class="spinner"></div>
            <span id="loadingText">Loading...</span> </div>
    </div>
    
    <footer class="footer">
        Created by Bixrail
    </footer>

    <script>
        // FFmpeg.wasm setup
        const { createFFmpeg, fetchFile } = FFmpeg;
        let ffmpeg; 

        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const penToolBtn = document.getElementById('penTool');
        const eraserToolBtn = document.getElementById('eraserTool');
        const strokeSizeSlider = document.getElementById('strokeSize');
        const strokeSizeValue = document.getElementById('strokeSizeValue');
        const strokeColorPicker = document.getElementById('strokeColor');
        const clearActiveLayerBtn = document.getElementById('clearActiveLayerBtn');
        const clearAllLayersBtn = document.getElementById('clearAllLayersBtn');

        const animationSliders = {
            wiggleIntensity: { slider: document.getElementById('wiggleIntensity'), valueEl: document.getElementById('wiggleIntensityValue'), suffix: '' },
            breathingStroke: { slider: document.getElementById('breathingStroke'), valueEl: document.getElementById('breathingStrokeValue'), suffix: '' },
            shakeIntensity: { slider: document.getElementById('shakeIntensity'), valueEl: document.getElementById('shakeIntensityValue'), suffix: '' },
            animationSpeed: { slider: document.getElementById('animationSpeed'), valueEl: document.getElementById('animationSpeedValue'), suffix: 'x' }
        };

        const saveBtn = document.getElementById('saveBtn');
        const loadInput = document.getElementById('loadInput');
        const exportMp4Btn = document.getElementById('exportMp4Btn'); 
        const loadingIndicator = document.getElementById('loadingIndicator');
        const loadingText = document.getElementById('loadingText'); 
        
        const messageModal = document.getElementById('messageModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalCloseBtn = document.getElementById('modalCloseBtn');

        const layersListContainer = document.getElementById('layersList');
        const addLayerBtn = document.getElementById('addLayerBtn');
        const selectedLayerOpacityControl = document.getElementById('selectedLayerOpacityControl');
        const layerOpacitySlider = document.getElementById('layerOpacity');
        const layerOpacityValue = document.getElementById('layerOpacityValue');
        
        const controlPanel = document.getElementById('controlPanel');
        const controlPanelToggle = document.getElementById('controlPanelToggle');

        let isDrawing = false;
        let currentTool = 'pen';
        let currentStrokeSize = 10;
        let currentStrokeColor = '#000000';
        
        let layers = [];
        let activeLayerId = null;

        let lastX, lastY;
        let animationFrameId;
        let time = 0; 
        let undoStack = [];
        let redoStack = [];

        function generateLayerId() { return Date.now() + Math.random().toString(36).substr(2, 9); }
        function getActiveLayer() { return layers.find(layer => layer.id === activeLayerId); }

        function setActiveToolButton(activeBtn) {
            [penToolBtn, eraserToolBtn].forEach(btn => btn.classList.remove('active-tool'));
            if (activeBtn) activeBtn.classList.add('active-tool');
            updateCanvasCursor(); 
        }
        
        function updateCanvasCursor() {
            const size = Math.max(2, currentStrokeSize); 
            let cursorSVG;
            if (currentTool === 'pen') {
                cursorSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}"><circle cx="${size/2}" cy="${size/2}" r="${size/2}" fill="rgba(0,0,0,0.5)"/></svg>`;
            } else if (currentTool === 'eraser') {
                const outlineWidth = Math.max(1, Math.min(2, size / 10)); 
                cursorSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}"><circle cx="${size/2}" cy="${size/2}" r="${size/2 - outlineWidth/2}" fill="rgba(255,255,255,0.5)" stroke="rgba(0,0,0,0.7)" stroke-width="${outlineWidth}"/></svg>`;
            } else {
                canvas.style.cursor = 'default';
                return;
            }
            canvas.style.cursor = `url('data:image/svg+xml;utf8,${encodeURIComponent(cursorSVG)}') ${size/2} ${size/2}, auto`;
        }

        function saveStateForUndo() {
            undoStack.push(JSON.parse(JSON.stringify(layers))); 
            if (undoStack.length > 30) undoStack.shift();
            redoStack = []; 
            updateUndoRedoButtons();
        }
        
        function updateUndoRedoButtons() {
            undoBtn.disabled = undoStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
            undoBtn.classList.toggle('btn-disabled', undoBtn.disabled);
            redoBtn.classList.toggle('btn-disabled', redoBtn.disabled);
        }

        function showModal(title, message, customButtons = null, isCustom = false) {
            modalTitle.textContent = title;
            modalMessage.innerHTML = message; // Use innerHTML for messages with HTML tags
            const buttonContainer = messageModal.querySelector('.modal-button-container');
            buttonContainer.innerHTML = ''; 
            if (isCustom && customButtons && customButtons.length > 0) {
                customButtons.forEach(btnConfig => {
                    const button = document.createElement('button');
                    button.textContent = btnConfig.text;
                    button.className = `btn modal-button ${btnConfig.class || 'btn-primary'}`;
                    button.onclick = btnConfig.action;
                    buttonContainer.appendChild(button);
                });
            } else {
                const closeButton = document.createElement('button');
                closeButton.id = 'modalCloseBtn'; 
                closeButton.className = 'btn modal-button btn-primary';
                closeButton.textContent = 'Close';
                closeButton.onclick = () => closeModal(messageModal);
                buttonContainer.appendChild(closeButton);
            }
            messageModal.classList.remove('hidden');
        }

        function closeModal(modalElement) { modalElement.classList.add('hidden'); }
        // modalCloseBtn is dynamically created now, so add listener to parent
        messageModal.addEventListener('click', (event) => { 
            if (event.target === messageModal || event.target.id === 'modalCloseBtn') {
                closeModal(messageModal);
            }
        });


        function resizeCanvas() {
            const canvasContainer = canvas.parentElement;
            const style = getComputedStyle(canvasContainer);
            const paddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
            const paddingY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
            const containerWidth = canvasContainer.clientWidth - paddingX;
            const containerHeight = canvasContainer.clientHeight - paddingY;
            canvas.width = Math.max(10, containerWidth); 
            canvas.height = Math.max(10, containerHeight);
            drawScene(); 
        }
        window.addEventListener('resize', resizeCanvas);
        
        controlPanelToggle.addEventListener('click', () => {
            controlPanel.classList.toggle('open');
            controlPanelToggle.innerHTML = controlPanel.classList.contains('open') ? '<i class="fas fa-times"></i>' : '<i class="fas fa-bars"></i>';
        });

        function createNewLayer(nameSuffix = layers.length + 1, strokes = [], customAnimationSettings = null, isVisible = true, opacity = 1, isActive = false) {
            const defaultAnimSettings = {};
            for (const key in animationSliders) {
                defaultAnimSettings[key] = parseFloat(animationSliders[key].slider.defaultValue || animationSliders[key].slider.value);
            }
            return {
                id: generateLayerId(), name: `Layer ${nameSuffix}`, strokes: strokes,
                animationSettings: customAnimationSettings || defaultAnimSettings,
                isVisible: isVisible, opacity: opacity, isActive: isActive 
            };
        }

        function addLayer() {
            saveStateForUndo();
            const newLayer = createNewLayer(layers.length + 1);
            const activeLayerIndex = layers.findIndex(l => l.id === activeLayerId);
            if (activeLayerIndex !== -1 && activeLayerIndex < layers.length -1) layers.splice(activeLayerIndex + 1, 0, newLayer);
            else layers.push(newLayer); 
            setActiveLayer(newLayer.id); 
            renderLayersList();
            updateAnimationSlidersForActiveLayer();
        }

        function setActiveLayer(layerId) {
            const previouslyActiveLayer = getActiveLayer();
            if (previouslyActiveLayer) previouslyActiveLayer.isActive = false;
            activeLayerId = layerId;
            const currentActiveLayer = getActiveLayer();
            if (currentActiveLayer) {
                currentActiveLayer.isActive = true;
                layerOpacitySlider.value = currentActiveLayer.opacity * 100;
                layerOpacityValue.textContent = Math.round(currentActiveLayer.opacity * 100);
                selectedLayerOpacityControl.classList.remove('hidden');
            } else selectedLayerOpacityControl.classList.add('hidden');
            renderLayersList(); 
            updateAnimationSlidersForActiveLayer();
        }
        
        layerOpacitySlider.addEventListener('input', (e) => {
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                activeLayer.opacity = parseFloat(e.target.value) / 100;
                layerOpacityValue.textContent = e.target.value;
                drawScene(); 
            }
        });

        function renderLayersList() {
            layersListContainer.innerHTML = ''; 
            if (layers.length === 0) {
                layersListContainer.innerHTML = '<p class="text-gray-500 text-sm p-2 text-center">No layers yet.</p>';
                selectedLayerOpacityControl.classList.add('hidden'); return;
            }
            [...layers].reverse().forEach((layer, R_index) => { 
                const index = layers.length - 1 - R_index; 
                const item = document.createElement('div');
                item.className = `layer-item ${layer.id === activeLayerId ? 'active-layer' : ''}`;
                item.dataset.layerId = layer.id;
                const visibilityBtn = document.createElement('button');
                visibilityBtn.className = 'btn btn-sm';
                visibilityBtn.innerHTML = `<i class="fas ${layer.isVisible ? 'fa-eye' : 'fa-eye-slash'}"></i>`;
                visibilityBtn.title = layer.isVisible ? "Hide" : "Show";
                visibilityBtn.onclick = (e) => { e.stopPropagation(); toggleLayerVisibility(layer.id); };
                const nameSpan = document.createElement('span');
                nameSpan.className = 'layer-name'; nameSpan.textContent = layer.name; nameSpan.title = "Rename";
                nameSpan.ondblclick = (e) => { e.stopPropagation(); makeLayerNameEditable(layer.id, nameSpan); };
                const controlsDiv = document.createElement('div'); controlsDiv.className = 'layer-controls';
                const upBtn = document.createElement('button'); upBtn.className = 'btn btn-sm'; upBtn.innerHTML = '<i class="fas fa-arrow-up"></i>'; upBtn.title = "Up";
                upBtn.disabled = index === layers.length - 1; upBtn.onclick = (e) => { e.stopPropagation(); moveLayer(layer.id, 'up'); };
                if(upBtn.disabled) upBtn.classList.add('btn-disabled');
                const downBtn = document.createElement('button'); downBtn.className = 'btn btn-sm'; downBtn.innerHTML = '<i class="fas fa-arrow-down"></i>'; downBtn.title = "Down";
                downBtn.disabled = index === 0; downBtn.onclick = (e) => { e.stopPropagation(); moveLayer(layer.id, 'down'); };
                if(downBtn.disabled) downBtn.classList.add('btn-disabled');
                const deleteBtn = document.createElement('button'); deleteBtn.className = 'btn btn-sm btn-danger'; deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>'; deleteBtn.title = "Delete";
                deleteBtn.onclick = (e) => { e.stopPropagation(); deleteLayer(layer.id); };
                controlsDiv.append(upBtn, downBtn, deleteBtn); item.append(visibilityBtn, nameSpan, controlsDiv);
                item.onclick = () => setActiveLayer(layer.id); layersListContainer.appendChild(item);
            });
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                selectedLayerOpacityControl.classList.remove('hidden');
                layerOpacitySlider.value = activeLayer.opacity * 100;
                layerOpacityValue.textContent = Math.round(activeLayer.opacity * 100);
            } else selectedLayerOpacityControl.classList.add('hidden');
        }
        
        function makeLayerNameEditable(layerId, nameSpan) {
            const layer = layers.find(l => l.id === layerId); if (!layer) return;
            const input = document.createElement('input'); input.type = 'text'; input.className = 'layer-name-input'; input.value = layer.name;
            nameSpan.replaceWith(input); input.focus(); input.select();
            const saveName = () => {
                saveStateForUndo(); layer.name = input.value.trim() || `Layer ${layers.findIndex(l => l.id === layerId) + 1}`;
                input.replaceWith(nameSpan); nameSpan.textContent = layer.name; 
            };
            input.onblur = saveName; input.onkeydown = (e) => { if (e.key === 'Enter') input.blur(); else if (e.key === 'Escape') { input.value = layer.name; input.blur(); }};
        }

        function toggleLayerVisibility(layerId) {
            saveStateForUndo(); const layer = layers.find(l => l.id === layerId);
            if (layer) layer.isVisible = !layer.isVisible; renderLayersList(); drawScene();
        }

        function deleteLayer(layerId) {
            if (layers.length <= 1) { showModal("Action Denied", "Cannot delete the last layer."); return; }
            const layerToDelete = layers.find(l => l.id === layerId); if (!layerToDelete) return;
            showModal("Confirm Deletion", `Delete layer "${layerToDelete.name}"?`, 
            [{ text: "Delete", class: 'btn-danger', action: () => {
                saveStateForUndo(); layers = layers.filter(l => l.id !== layerId);
                if (activeLayerId === layerId) setActiveLayer(layers.length > 0 ? layers[layers.length - 1].id : null);
                renderLayersList(); drawScene(); closeModal(messageModal);
            }},{ text: "Cancel", class: 'btn', action: () => closeModal(messageModal) }], true);
        }

        function moveLayer(layerId, direction) {
            saveStateForUndo(); const index = layers.findIndex(l => l.id === layerId); if (index === -1) return;
            if (direction === 'up' && index < layers.length - 1) [layers[index], layers[index + 1]] = [layers[index + 1], layers[index]];
            else if (direction === 'down' && index > 0) [layers[index], layers[index - 1]] = [layers[index - 1], layers[index]];
            renderLayersList(); drawScene();
        }

        function updateAnimationSlidersForActiveLayer() {
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                for (const key in animationSliders) {
                    const setting = activeLayer.animationSettings[key];
                    if (setting !== undefined) {
                        animationSliders[key].slider.value = setting;
                        animationSliders[key].valueEl.textContent = setting + (animationSliders[key].suffix || '');
                    }
                }
            } else {
                 for (const key in animationSliders) {
                    animationSliders[key].slider.value = animationSliders[key].slider.defaultValue || 0;
                    animationSliders[key].valueEl.textContent = (animationSliders[key].slider.defaultValue || 0) + (animationSliders[key].suffix || '');
                 }
            }
        }

        Object.values(animationSliders).forEach(item => {
            item.slider.addEventListener('input', (e) => {
                const activeLayer = getActiveLayer();
                if (activeLayer) {
                    const key = Object.keys(animationSliders).find(k => animationSliders[k].slider === e.target);
                    if (key) {
                        activeLayer.animationSettings[key] = parseFloat(e.target.value);
                        item.valueEl.textContent = e.target.value + (item.suffix || '');
                    }
                }
            });
        });

        function startDrawing(e) {
            const activeLayer = getActiveLayer();
            if (!activeLayer || !activeLayer.isVisible) return; 
            if (e.button !== 0 && e.type === 'mousedown') return; 
            
            saveStateForUndo(); 
            isDrawing = true;
            const { offsetX, offsetY } = getMousePos(e);
            
            activeLayer.strokes.push({
                points: [{ x: offsetX, y: offsetY }],
                color: currentTool === 'pen' ? currentStrokeColor : '#FFFFFF', 
                size: currentStrokeSize, tool: currentTool, originalSize: currentStrokeSize,
                birthTime: time, 
            });
            [lastX, lastY] = [offsetX, offsetY];
        }

        function draw(e) {
            const activeLayer = getActiveLayer();
            if (!isDrawing || !activeLayer || !activeLayer.isVisible) return;

            const { offsetX, offsetY } = getMousePos(e);
            const currentPath = activeLayer.strokes[activeLayer.strokes.length - 1];
            if (!currentPath) { isDrawing = false; return; }
            currentPath.points.push({ x: offsetX, y: offsetY });
  
            ctx.save();
            ctx.globalAlpha = activeLayer.opacity; 
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(offsetX, offsetY);
            ctx.strokeStyle = currentTool === 'eraser' ? '#FFFFFF' : currentPath.color;
            ctx.lineWidth = currentPath.size;
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.stroke();
            ctx.restore();
            [lastX, lastY] = [offsetX, offsetY];
        }

        function stopDrawing() { if (isDrawing) isDrawing = false; }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                return { offsetX: e.touches[0].clientX - rect.left, offsetY: e.touches[0].clientY - rect.top };
            }
            return { offsetX: e.clientX - rect.left, offsetY: e.clientY - rect.top };
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing); 

        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDrawing(e); }, { passive: false });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e); }, { passive: false });
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); stopDrawing(); }, { passive: false });
        canvas.addEventListener('touchcancel', (e) => { e.preventDefault(); stopDrawing(); }, { passive: false });


        penToolBtn.addEventListener('click', () => { currentTool = 'pen'; setActiveToolButton(penToolBtn); });
        eraserToolBtn.addEventListener('click', () => { currentTool = 'eraser'; setActiveToolButton(eraserToolBtn); });

        strokeSizeSlider.addEventListener('input', (e) => { 
            currentStrokeSize = parseInt(e.target.value); 
            strokeSizeValue.textContent = currentStrokeSize; 
            updateCanvasCursor();
        });
        strokeColorPicker.addEventListener('input', (e) => { currentStrokeColor = e.target.value; });
        
        clearActiveLayerBtn.addEventListener('click', () => { 
            const activeLayer = getActiveLayer();
            if (!activeLayer || activeLayer.strokes.length === 0) {
                showModal("Clear Layer", "Active layer is already empty.");
                return;
            }
            showModal("Confirm Clear Layer", `Clear all strokes from layer "${activeLayer.name}"?`,
            [{text: "Clear Layer", class: 'btn-danger', action: () => {
                saveStateForUndo(); 
                activeLayer.strokes = []; 
                drawScene(); closeModal(messageModal);
            }},{text: "Cancel", class: 'btn', action: () => closeModal(messageModal)}], true);
        });
        
        clearAllLayersBtn.addEventListener('click', () => {
            if (layers.every(l => l.strokes.length === 0)) {
                 showModal("Clear All Layers", "All layers are already empty.");
                return;
            }
            showModal("Confirm Clear All", "Clear strokes from ALL layers? This action affects all layers.",
            [{text: "Clear All", class: 'btn-danger', action: () => {
                saveStateForUndo(); 
                layers.forEach(layer => layer.strokes = []); 
                drawScene(); closeModal(messageModal);
            }},{text: "Cancel", class: 'btn', action: () => closeModal(messageModal)}], true);
        });


        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');

        undoBtn.addEventListener('click', () => {
            if (undoStack.length > 0) {
                redoStack.push(JSON.parse(JSON.stringify(layers))); 
                layers = undoStack.pop(); 
                const currentActiveStillExists = layers.find(l => l.id === activeLayerId);
                if (!currentActiveStillExists && layers.length > 0) activeLayerId = layers[layers.length - 1].id;
                else if (layers.length === 0) activeLayerId = null;
                layers.forEach(l => l.isActive = (l.id === activeLayerId));
                renderLayersList(); updateAnimationSlidersForActiveLayer(); drawScene(); updateUndoRedoButtons();
            }
        });

        redoBtn.addEventListener('click', () => {
            if (redoStack.length > 0) {
                undoStack.push(JSON.parse(JSON.stringify(layers))); 
                layers = redoStack.pop(); 
                const currentActiveStillExists = layers.find(l => l.id === activeLayerId);
                if (!currentActiveStillExists && layers.length > 0) activeLayerId = layers[layers.length - 1].id;
                else if (layers.length === 0) activeLayerId = null;
                layers.forEach(l => l.isActive = (l.id === activeLayerId));
                renderLayersList(); updateAnimationSlidersForActiveLayer(); drawScene(); updateUndoRedoButtons();
            }
        });

        function drawScene(isExporting = false, exportTimeOverride = null) {
            const currentTime = isExporting ? exportTimeOverride : time;

            ctx.fillStyle = '#FFFFFF'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            layers.forEach(layer => {
                if (!layer.isVisible || layer.strokes.length === 0) return;
                ctx.save(); ctx.globalAlpha = layer.opacity; 
                const animSettings = layer.animationSettings;
                const animSpeed = parseFloat(animSettings.animationSpeed); 
                const wiggleAmp = parseFloat(animSettings.wiggleIntensity);
                const breathAmount = parseFloat(animSettings.breathingStroke);
                const shakeAmount = parseFloat(animSettings.shakeIntensity);

                layer.strokes.forEach(stroke => {
                    if (!stroke.points || stroke.points.length < 1) return;
                    ctx.save(); 

                    if (shakeAmount > 0 && !isExporting) { 
                        const shakeX = (Math.random() - 0.5) * shakeAmount * animSpeed; 
                        const shakeY = (Math.random() - 0.5) * shakeAmount * animSpeed;
                        ctx.translate(shakeX, shakeY);
                    }
                    let currentDynamicSize = stroke.originalSize;
                    if (breathAmount > 0) {
                        currentDynamicSize = stroke.originalSize + Math.sin(currentTime * 0.1 * animSpeed + stroke.birthTime) * breathAmount;
                        currentDynamicSize = Math.max(1, currentDynamicSize);
                    }
                    ctx.beginPath();
                    if (stroke.points.length === 1) { 
                        const p = stroke.points[0];
                        ctx.arc(p.x, p.y, currentDynamicSize / 2, 0, Math.PI * 2);
                        ctx.fillStyle = stroke.tool === 'eraser' ? '#FFFFFF' : stroke.color; ctx.fill();
                    } else { 
                        for (let i = 0; i < stroke.points.length; i++) {
                            let p = { ...stroke.points[i] }; 
                            if (wiggleAmp > 0 && i > 0) {
                                const prevP = stroke.points[i-1]; const dx = p.x - prevP.x; const dy = p.y - prevP.y;
                                const angle = Math.atan2(dy, dx); const normalAngle = angle + Math.PI / 2; 
                                const wiggleOffset = Math.sin(currentTime * 0.1 * animSpeed + i * 0.5 + stroke.birthTime * 0.01) * wiggleAmp;
                                p.x += Math.cos(normalAngle) * wiggleOffset; p.y += Math.sin(normalAngle) * wiggleOffset;
                            }
                            if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
                        }
             
                        ctx.strokeStyle = stroke.tool === 'eraser' ? '#FFFFFF' : stroke.color;
                        ctx.lineWidth = currentDynamicSize;
                        ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.stroke();
                    }
                    ctx.restore(); 
                });
                ctx.restore(); 
            });
        }

        function animate() { time += 1; drawScene(); animationFrameId = requestAnimationFrame(animate); }
        
        strokeSizeSlider.addEventListener('input', (e) => { 
            currentStrokeSize = parseInt(e.target.value); 
            strokeSizeValue.textContent = currentStrokeSize; 
            updateCanvasCursor();
        });

        saveBtn.addEventListener('click', () => {
            if (layers.length === 0 || layers.every(l => l.strokes.length === 0)) { showModal("Save Sketch", "Canvas empty."); return; }
            const dataToSave = { layers: layers, activeLayerId: activeLayerId, canvasWidth: canvas.width, canvasHeight: canvas.height };
            const jsonData = JSON.stringify(dataToSave); const blob = new Blob([jsonData], { type: 'application/octet-stream' }); 
            const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url;
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-'); a.download = `drawerz_sketch_${timestamp}.drz`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            showModal("Save Sketch", "Sketch saved as .drz file!");
        });

        loadInput.addEventListener('change', (e) => {
            const file = e.target.files[0]; if (!file) return;
            loadingIndicator.classList.remove('hidden'); 
            if(loadingText) loadingText.textContent = "Loading sketch...";
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    if (data.layers && Array.isArray(data.layers)) {
                        saveStateForUndo(); 
                        layers = data.layers.map(loadedLayer => {
                            const defaultAnim = {};
                            for (const key in animationSliders) defaultAnim[key] = parseFloat(animationSliders[key].slider.defaultValue || 0);
                  
                            return {
                                id: loadedLayer.id || generateLayerId(), name: loadedLayer.name || 'Loaded Layer',
                                strokes: loadedLayer.strokes || [],
                                animationSettings: { ...defaultAnim, ...(loadedLayer.animationSettings || {}) }, 
                                isVisible: loadedLayer.isVisible !== undefined ? loadedLayer.isVisible : true,
                                opacity: loadedLayer.opacity !== undefined ? loadedLayer.opacity : 1, isActive: false
                            };
                        });
                        if (data.activeLayerId && layers.find(l => l.id === data.activeLayerId)) activeLayerId = data.activeLayerId;
                        else if (layers.length > 0) activeLayerId = layers[layers.length - 1].id;
                        else activeLayerId = null;
                        layers.forEach(l => l.isActive = (l.id === activeLayerId));
                        renderLayersList(); updateAnimationSlidersForActiveLayer(); resizeCanvas(); 
                        showModal("Load Sketch", "Sketch loaded!");
                    } else showModal("Load Error", "Invalid .drz file. Missing 'layers' data.");
                } catch (error) { console.error("Load error:", error); showModal("Load Error", "Could not load sketch. " + error.message);
                } finally { loadingIndicator.classList.add('hidden'); loadInput.value = ''; }
            };
            reader.onerror = () => { showModal("Load Error", "Error reading file."); loadingIndicator.classList.add('hidden'); loadInput.value = ''; };
            reader.readAsText(file);
        });
        
        async function initializeFFmpeg() {
            if (!ffmpeg) { // Initialize FFmpeg instance only once
                 ffmpeg = createFFmpeg({ 
                    log: true, // Enable FFmpeg logs in console for debugging
                    corePath: 'https://unpkg.com/@ffmpeg/core@0.11.0/dist/ffmpeg-core.js',
                 });
            }
            if (!ffmpeg.isLoaded()) {
                if(loadingText) loadingText.textContent = "Loading FFmpeg library (~30MB)...";
                loadingIndicator.classList.remove('hidden'); // Show while loading FFmpeg library itself
                await ffmpeg.load();
            }
        }

        async function checkAndLoadFFmpeg() {
            if (typeof SharedArrayBuffer === 'undefined') {
                let sabMessage = "<p>MP4 export uses FFmpeg.wasm, which requires <code>SharedArrayBuffer</code>.</p>" +
                                 "<p>This feature is often disabled by browsers unless the page is served with specific HTTP headers (COOP & COEP).</p>";
                if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                sabMessage += "<p>A Service Worker is active, which attempts to set these headers. If <code>SharedArrayBuffer</code> is still unavailable, please try **reloading the page** (sometimes a hard refresh: Ctrl+Shift+R or Cmd+Shift+R is needed). If the issue persists, your hosting environment or browser settings might be preventing it.</p>";
                } else if ('serviceWorker' in navigator) {
                sabMessage += "<p>A Service Worker is attempting to register to enable this. This might be its first activation. Please **reload the page** and try exporting again. If MP4 export still fails, the Service Worker might not have activated correctly or your environment has restrictions.</p>";
                } else {
                sabMessage += "<p>Your browser does not support Service Workers, or support is disabled. Service Workers are used here to attempt to set the required headers on this hosting platform.</p>";
                }
                sabMessage += "<p>For MP4 export to work, the page needs to be served with:<br>" +
                              "<code>Cross-Origin-Opener-Policy: same-origin</code><br>" +
                              "<code>Cross-Origin-Embedder-Policy: require-corp</code></p>" +
                              "<p>If reloading doesn't help, consider using a different browser or a hosting platform that allows setting these headers directly if MP4 export is essential.</p>";
                showModal("MP4 Export Prerequisite Missing", sabMessage);
                return false;
            }

            try {
                await initializeFFmpeg(); // Ensure FFmpeg is loaded
            } catch (err) {
                console.error("FFmpeg load error:", err);
                showModal("FFmpeg Load Error", "Failed to load FFmpeg components. MP4 export is unavailable. Error: " + err.message);
                loadingIndicator.classList.add('hidden');
                return false;
            }
            return true;
        }


        exportMp4Btn.addEventListener('click', async () => { 
            if (layers.every(l => !l.isVisible || l.strokes.length === 0)) { 
                showModal("Export Error", "No visible content to export."); return; 
            }

            const ffmpegReady = await checkAndLoadFFmpeg();
            if (!ffmpegReady) {
                loadingIndicator.classList.add('hidden'); 
                return; 
            }
            
            const globalExportAnimSpeedFactor = parseFloat(animationSliders.animationSpeed.slider.value);
            if (globalExportAnimSpeedFactor <= 0) {
                showModal("Export Warning", "Global Animation Speed is zero or less. The exported video will not show animation. Please increase the Animation Speed slider value if you want animated export.");
                // Allow proceeding, will result in a static-like video if speed is 0.
            }

            loadingIndicator.classList.remove('hidden');
            if(loadingText) loadingText.textContent = "Preparing video export...";

            const frameRate = 30; 
            const durationSeconds = 15; 
            const totalFrames = frameRate * durationSeconds;
            
            const liveAnimationTimeAtStart = time; 
            let exportRenderTime = liveAnimationTimeAtStart; 
            const timeStepPerVideoFrame = globalExportAnimSpeedFactor * (60 / frameRate);

            if (animationFrameId) cancelAnimationFrame(animationFrameId); 

            let currentFrame = 0;
            const frameFileNames = [];

            async function renderAndSaveFrame() {
                if (currentFrame >= totalFrames) {
                    await compileVideo();
                    return;
                }
                if(loadingText) loadingText.textContent = `Rendering frame ${currentFrame + 1} of ${totalFrames}...`;
                
                drawScene(true, exportRenderTime); 

                const frameName = `frame${String(currentFrame).padStart(4, '0')}.png`;
                frameFileNames.push(frameName);
                
                try {
                    const dataUrl = canvas.toDataURL('image/png');
                    // FFmpeg's fetchFile can sometimes be slow or have issues with very large data URLs or many files.
                    // Converting to blob first might be more robust for FFmpeg.
                    const blob = await (await fetch(dataUrl)).blob();
                    const arrayBuffer = await blob.arrayBuffer();
                    ffmpeg.FS('writeFile', frameName, new Uint8Array(arrayBuffer));
                } catch (frameError) {
                    console.error(`Error processing frame ${frameName}:`, frameError);
                    showModal("Frame Processing Error", `Failed to process frame ${currentFrame + 1}. Export aborted.`);
                    // Cleanup and restore
                    frameFileNames.forEach(name => { try { ffmpeg.FS('unlink', name); } catch(e){} });
                    loadingIndicator.classList.add('hidden');
                    time = liveAnimationTimeAtStart; 
                    animate();
                    return;
                }


                exportRenderTime += timeStepPerVideoFrame;
                currentFrame++;
                setTimeout(renderAndSaveFrame, 1); 
            }

            async function compileVideo() {
                if(loadingText) loadingText.textContent = "Encoding MP4... This may take a while.";
                try {
                    await ffmpeg.run('-r', String(frameRate), '-i', 'frame%04d.png', '-c:v', 'libx264', '-preset', 'ultrafast', '-crf', '23', '-pix_fmt', 'yuv420p', 'output.mp4');
                    const data = ffmpeg.FS('readFile', 'output.mp4');
                    
                    const blob = new Blob([data.buffer], { type: 'video/mp4' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a'); a.href = url;
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-'); 
                    a.download = `drawerz_animation_${timestamp}.mp4`;
                    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                    showModal("Export Complete", "Animation exported as MP4!");

                } catch (error) {
                    console.error("FFmpeg run error:", error);
                    showModal("FFmpeg Export Error", "Error during video encoding: " + error.message);
                } finally {
                    frameFileNames.forEach(name => { try { ffmpeg.FS('unlink', name); } catch(e){} });
                    try { ffmpeg.FS('unlink', 'output.mp4'); } catch(e){}
                    
                    loadingIndicator.classList.add('hidden');
                    time = liveAnimationTimeAtStart; 
                    animate(); 
                }
            }
            renderAndSaveFrame(); 
        });


        function initializeApp() {
            // Service Worker Registration
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./sw.js', { scope: './' }) // Ensure scope is correct for GitHub Pages
                    .then(registration => {
                        console.log('Drawerz Service Worker: Registered with scope:', registration.scope);
                        
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            if (newWorker) {
                                newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'activated') {
                                    if (navigator.serviceWorker.controller) {
                                    console.log('Drawerz Service Worker: New version activated. A reload might be needed for changes to take full effect.');
                                    // Optionally show a small, non-intrusive "Update available, reload?" message
                                    } else {
                                    console.log('Drawerz Service Worker: Activated for the first time. Page may need a reload for COOP/COEP headers.');
                                    // This is a good place to inform the user if SharedArrayBuffer is still not available
                                    if (typeof SharedArrayBuffer === 'undefined') {
                                        showModal("Service Worker Active", "The helper Service Worker is now active. Please try reloading the page if MP4 export initially fails due to missing requirements.");
                                    }
                                    }
                                }
                                });
                            }
                        });
                    }).catch(error => {
                        console.error('Drawerz Service Worker: Registration failed:', error);
                    });

                    navigator.serviceWorker.addEventListener('message', event => {
                        if (event.data && event.data.type === 'SW_ACTIVATED') {
                            console.log('Drawerz Service Worker: Received SW_ACTIVATED message from SW.');
                             if (typeof SharedArrayBuffer === 'undefined') {
                                console.warn('SW activated, but SharedArrayBuffer still undefined. A page reload may be required for COOP/COEP headers to take effect.');
                            }
                        }
                    });

                    // Initial check on load if controlled by SW but SAB is missing
                    if (navigator.serviceWorker.controller && typeof SharedArrayBuffer === 'undefined') {
                        console.warn('Page is controlled by a Service Worker, but SharedArrayBuffer is undefined. Ensure SW sets COOP/COEP headers, or try a hard refresh (Ctrl+Shift+R).');
                    }
                });
            }


            loadingIndicator.classList.add('hidden'); messageModal.classList.add('hidden');
            setActiveToolButton(penToolBtn); 
            strokeSizeValue.textContent = strokeSizeSlider.value;
            if (layers.length === 0) { const initialLayer = createNewLayer(1); layers.push(initialLayer); setActiveLayer(initialLayer.id); }
            else setActiveLayer(layers.find(l => l.isActive)?.id || layers[0]?.id);
            renderLayersList(); updateAnimationSlidersForActiveLayer(); updateUndoRedoButtons(); 
            resizeCanvas(); animate(); 
            updateCanvasCursor();
        }
        addLayerBtn.addEventListener('click', addLayer);
        document.addEventListener('keydown', function(e) {
            const activeEl = document.activeElement;
            const isInputFocused = activeEl && (activeEl.tagName.toLowerCase() === 'input' && activeEl.type !== 'range' && activeEl.type !== 'button' && activeEl.type !== 'submit') || activeEl.tagName.toLowerCase() === 'textarea';
            if (isInputFocused) return; 
            let prevented = true; 
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') saveBtn.click();
            else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'o') document.getElementById('loadInput').click();
            else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'e') exportMp4Btn.click();
            else if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.code === 'Delete') { clearAllLayersBtn.click(); } 
            else if ((e.ctrlKey || e.metaKey) && e.code === 'Delete') { clearActiveLayerBtn.click(); } 
            else if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'z') { undoBtn.click(); }
            else if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))) { redoBtn.click(); }
            else if (e.key.toLowerCase() === 'p' && !e.ctrlKey && !e.metaKey) penToolBtn.click();
            else if (e.key.toLowerCase() === 'e' && !e.ctrlKey && !e.metaKey) eraserToolBtn.click();
            else prevented = false;
            if (prevented) e.preventDefault();
        });
        initializeApp();
    </script>
</body>
</html>
