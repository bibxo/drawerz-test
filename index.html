<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawerz Beta 3 - Animated Sketchpad & Layering Tool</title>

    <link rel="icon" type="image/png" href="icon-logo.png">

    <meta name="description" content="Drawerz Beta 3: A creative web application for drawing, animating strokes with layers, and exporting your artwork as MP4 or GIF. Features include dynamic brushes, layer management, and various animation effects.">
    <meta name="keywords" content="drawing app, animation tool, vector graphics, layers, sketchpad, online drawing, html5 canvas, javascript animation, export mp4, export gif, Drawerz">
    <meta name="author" content="Bixrail & Your Name/Studio"> <link rel="canonical" href="https://your-drawerz-beta-3-url.com/"> <meta name="robots" content="index, follow">

    <meta property="og:title" content="Drawerz Beta 3 - Animated Sketchpad">
    <meta property="og:description" content="Create and animate drawings with layers. Export to MP4 or GIF.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://your-drawerz-beta-3-url.com/"> <meta property="og:image" content="chat-logo.png"> 
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Drawerz Beta 3">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Drawerz Beta 3 - Animated Sketchpad">
    <meta name="twitter:description" content="Create and animate drawings with layers. Export to MP4 or GIF.">
    <meta name="twitter:image" content="chat-logo.png"> 
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.0/dist/ffmpeg.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
</head>
<body class="bg-gray-900 text-white flex flex-col h-screen overflow-hidden">
    <style>
        /* Base styles */
        body, html {
            font-family: 'Montserrat', sans-serif !important; 
            overscroll-behavior: none;
            background-color: #111827; 
            color: #e5e7eb; 
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

     
        .header {
            background-color: #1f2937; 
            padding: 0.75rem 1rem; 
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); 
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #374151; 
            flex-shrink: 0; 
            z-index: 20; 
        }

        .header-logo-link { /* For the logo image to be clickable (e.g., to homepage) */
            display: inline-block; /* Allows setting height/width if needed on the link itself */
        }
        .header-logo {
            height: 32px; /* Adjust as needed, e.g., 30-40px */
            width: auto;  /* Maintain aspect ratio */
            object-fit: contain; /* Ensures logo isn't distorted */
            vertical-align: middle; /* Aligns image nicely if there's text next to it */
        }


        .header-buttons {
            display: flex;
            gap: 0.5rem; 
            align-items: center;
            flex-wrap: nowrap; 
        }
        .control-panel-toggle { 
            display: none; 
            background: none;
            border: none;
            color: #9ca3af;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            font-family: 'Montserrat', sans-serif;
        }


        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden; 
            position: relative; 
        }

        .canvas-container {
            flex: 1;
            padding: 0.5rem; 
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #374151; 
            overflow: hidden; 
            position: relative; 
        }

        #drawingCanvas {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
            max-width: 100%;
            max-height: 100%;
            border: 1px solid #4b5563; 
            transform-origin: 0 0; 
        }


        .control-panel {
            width: 24rem; 
            background-color: #111827; 
            padding: 1rem; 
            box-shadow: -5px 0 15px -3px rgba(0, 0, 0, 0.1); 
            display: flex;
            flex-direction: column;
            gap: 1.25rem; 
            border-left: 1px solid #374151; 
            max-height: 100%; 
            overflow-y: auto; 
            transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out; 
            z-index: 10; 
            font-family: 'Montserrat', sans-serif;
        }

        .section { display: flex; flex-direction: column; gap: 0.75rem; }
        .section-title {
            font-size: 1.1rem; 
            font-weight: 600; 
            color: #9ca3af; 
            border-bottom: 1px solid #374151; 
            padding-bottom: 0.4rem;
            margin-bottom: 0.2rem; 
            font-family: 'Montserrat', sans-serif;
        }

        .tools-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); gap: 0.5rem; } 

        .btn {
            display: inline-flex; 
            align-items: center;
            justify-content: center;
            gap: 0.5rem; 
            padding: 0.5rem 0.75rem; 
            border-radius: 0.375rem; 
            font-weight: 500; 
            transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.15s ease-in-out;
            cursor: pointer;
            border: 1px solid #4b5563; 
            font-size: 0.8rem; 
            color: #d1d5db; 
            background-color: #374151; 
            white-space: nowrap; 
            font-family: 'Montserrat', sans-serif !important; 
        }
        .btn i { font-size: 0.9em; } 


        .btn:hover:not(:disabled) {
            transform: translateY(-1px); 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            background-color: #4b5563; 
            border-color: #6b7280;
        }
        .btn:active:not(:disabled) {
            transform: translateY(0px);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
            background-color: #2d3748; 
        }
        .btn.active-tool, .btn.active-layer-control { 
            background-color: #2563eb !important; 
            color: white !important;
            border-color: #3b82f6 !important; 
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); 
        }
        .btn.active-tool:hover, .btn.active-layer-control:hover { background-color: #1d4ed8 !important; }
        .btn-primary { background-color: #3b82f6; color: white; border-color: #3b82f6; }
        .btn-primary:hover:not(:disabled) { background-color: #2563eb; border-color: #2563eb;}
        .btn-primary:active:not(:disabled) { background-color: #1d4ed8; }
        .btn-danger { background-color: #ef4444; color: white; border-color: #ef4444; }
        .btn-danger:hover:not(:disabled) { background-color: #dc2626; border-color: #dc2626; }
        .btn-danger:active:not(:disabled) { background-color: #b91c1c; }
        .btn:disabled, .btn.btn-disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
        label.btn { display: inline-flex; }
        #loadInput { display: none; }

        .form-group { display: flex; flex-direction: column; gap: 0.4rem; }
        .form-label { font-size: 0.8rem; font-weight: 500; color: #9ca3af; font-family: 'Montserrat', sans-serif; }
        .form-label span { color: #e5e7eb; } 
        input[type="range"] { width: 100%; height: 0.5rem; background-color: #374151; border-radius: 9999px; appearance: none; cursor: pointer; transition: background-color 0.15s ease-in-out; }
        input[type="range"]:hover { background-color: #4b5563; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 1rem; height: 1rem; background: #3b82f6; border-radius: 50%; cursor: pointer; border: 2px solid white; transition: background-color 0.15s ease-in-out, transform 0.1s ease-in-out; }
        input[type="range"]::-moz-range-thumb { width: 0.8rem; height: 0.8rem; background: #3b82f6; border-radius: 50%; cursor: pointer; border: 2px solid white; transition: background-color 0.15s ease-in-out, transform 0.1s ease-in-out; }
        input[type="range"]:hover::-webkit-slider-thumb { background: #2563eb; transform: scale(1.1); }
        input[type="range"]:hover::-moz-range-thumb { background: #2563eb; transform: scale(1.1); }
        input[type="color"] { width: 100%; height: 2.25rem; padding: 0.125rem; background-color: #374151; border: 1px solid #4b5563; border-radius: 0.375rem; cursor: pointer; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 0.25rem; }
        input[type="color"]::-moz-color-swatch { border: none; border-radius: 0.25rem; }

        .footer { padding: 0.75rem; background-color: #1f2937; color: #6b7280; text-align: center; font-size: 0.75rem; border-top: 1px solid #374151; flex-shrink: 0; font-family: 'Montserrat', sans-serif;}
        .hidden { display: none !important; }
        #loadingIndicator { position: fixed; inset: 0; background-color: rgba(17, 24, 39, 0.8); display: flex; justify-content: center; align-items: center; z-index: 100; }
        .loading-content { display: flex; flex-direction: column; align-items: center; gap: 1rem; background-color: #1f2937; padding: 2rem; border-radius: 0.5rem; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); color: #e5e7eb; }
        .loading-content span { font-family: 'Montserrat', sans-serif; } 
        .spinner { border: 4px solid #4b5563; border-top-color: #3b82f6; border-radius: 50%; width: 2.5rem; height: 2.5rem; animation: spin 0.8s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .modal { position: fixed; inset: 0; background-color: rgba(17, 24, 39, 0.8); display: flex; justify-content: center; align-items: center; z-index: 100; padding: 1rem; }
        .modal-content { background-color: #1f2937; color: #e5e7eb; padding: 1.5rem 2rem; border-radius: 0.5rem; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); max-width: 36rem; width: 100%; text-align: left; display: flex; flex-direction: column; gap: 1rem; font-family: 'Montserrat', sans-serif;}
        .modal-title { font-size: 1.25rem; font-weight: 600; color: white; }
        .modal-message { color: #d1d5db; font-size: 0.925rem; line-height: 1.6; }
        .modal-message ul { list-style-type: disc; padding-left: 1.5rem; margin-top: 0.5rem; }
        .modal-message code { background-color: #374151; padding: 0.1em 0.4em; border-radius: 0.25rem; font-size: 0.85em; }
        .modal-button-container { display: flex; justify-content: flex-end; margin-top: 1rem; }
        .modal-button { background-color: #3b82f6; color: white; font-weight: 500; padding: 0.625rem 1.25rem; border-radius: 0.375rem; border: 1px solid #3b82f6; font-family: 'Montserrat', sans-serif !important; }
        .modal-button:hover { background-color: #2563eb; border-color: #2563eb; }

        .layers-list { display: flex; flex-direction: column; gap: 0.5rem; max-height: 180px; overflow-y: auto; border: 1px solid #374151; border-radius: 0.375rem; padding: 0.5rem; }
        .layer-item { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; border-radius: 0.25rem; background-color: #1f2937; border: 1px solid #374151; cursor: pointer; transition: background-color 0.15s ease, border-color 0.15s ease; }
        .layer-item:hover { background-color: #2d3748; }
        .layer-item.active-layer { background-color: #3b82f6; border-color: #2563eb; color: white; }
        .layer-item.active-layer .layer-name, .layer-item.active-layer .layer-opacity-value { color: white; }
        .layer-name { flex-grow: 1; font-size: 0.8rem; color: #d1d5db; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .layer-name-input { flex-grow: 1; font-size: 0.8rem; background-color: #374151; color: white; border: 1px solid #4b5563; border-radius: 0.25rem; padding: 0.25rem 0.5rem; font-family: 'Montserrat', sans-serif; }
        .layer-controls { display: flex; gap: 0.25rem; }
        .layer-controls .btn { padding: 0.25rem 0.375rem; font-size: 0.7rem; } 
        .layer-opacity-control { display: flex; flex-direction: column; gap: 0.25rem; margin-top: 0.5rem; }
        .layer-opacity-control input[type="range"] { height: 0.4rem; }
        .layer-opacity-control .form-label { font-size: 0.8rem; }
        .layer-actions { display: flex; gap: 0.5rem; margin-top: 0.5rem; flex-wrap: wrap; }
        .layer-actions .btn { flex-grow: 1; min-width: 80px; } 

        ::-webkit-scrollbar { width: 0.5rem; height: 0.5rem; } 
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 0.25rem; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        @media (max-width: 900px) { 
            .header-title { font-size: 1.1rem; }
            .header-buttons .btn span { display: none; } 
            .header-buttons .btn i { margin-right: 0; } 
            .header-buttons .btn { padding: 0.5rem; } 


            .control-panel {
                position: absolute;
                right: 0;
                top: 0;
                bottom: 0;
                transform: translateX(100%); 
                border-left: 1px solid #374151;
                box-shadow: -2px 0 10px rgba(0,0,0,0.3); 
                width: 280px; 
            }
            .control-panel.open {
                transform: translateX(0);
            }
            .control-panel-toggle {
                display: block; 
            }
        }
         @media (max-width: 480px) { 
            .header-buttons { gap: 0.25rem; }
            .header-buttons .btn { padding: 0.4rem; font-size: 0.7rem; }
            .header-buttons .btn i { font-size: 0.8em; }
            .control-panel { width: calc(100% - 40px); max-width: 280px; } 
            .section-title { font-size: 1rem; }
            .form-label { font-size: 0.75rem; }
            .layer-name, .layer-name-input { font-size: 0.75rem; }
         }
    </style>

    <header class="header">
        <a href="#" class="header-logo-link">
            <img src="head-logo.png" alt="Drawerz Beta 3 Logo" class="header-logo" onerror="this.onerror=null;this.src='https://placehold.co/200x40/3B82F6/FFFFFF?text=Drawerz&font=montserrat';">
        </a>
        <div class="header-buttons">
            <button id="saveBtn" class="btn" title="Save (Ctrl + S)"><i class="fas fa-save"></i> <span>Save</span></button>
            <label for="loadInput" class="btn" title="Load (Ctrl + O)"><i class="fas fa-folder-open"></i> <span>Load</span></label>
            <input type="file" id="loadInput" accept=".drz,.svg,.psd,.clip"> 
            <button id="exportMp4Btn" class="btn btn-primary" title="Export MP4 (Ctrl + E)"><i class="fas fa-file-video"></i> <span>Export MP4</span></button>
            <button id="exportGifBtn" class="btn btn-primary" title="Export GIF"><i class="fas fa-file-image"></i> <span>Export GIF</span></button>
            <button id="clearActiveLayerBtn" class="btn btn-danger" title="Clear Active Layer"><i class="fas fa-eraser"></i> <span>Clear Layer</span></button>
            <button id="clearAllLayersBtn" class="btn btn-danger" title="Clear All Layers (Ctrl + Shift + Delete)"><i class="fas fa-bomb"></i> <span>Clear All</span></button>
            <button id="undoBtn" class="btn" title="Undo (Ctrl + Z)"><i class="fas fa-undo"></i></button>
            <button id="redoBtn" class="btn" title="Redo (Ctrl + Y)"><i class="fas fa-redo"></i></button>
        </div>
        <button id="controlPanelToggle" class="control-panel-toggle"><i class="fas fa-bars"></i></button>
    </header>

    <div class="main-content">
        <div class="canvas-container">
            <canvas id="drawingCanvas"></canvas>
        </div>

        <aside id="controlPanel" class="control-panel">
            <div class="section">
                <h2 class="section-title">Drawing Tools</h2>
                <div class="tools-grid">
                    <button id="penTool" class="btn active-tool" title="Pen Tool (P)"><i class="fas fa-pen"></i> Pen</button>
                    <button id="eraserTool" class="btn" title="Eraser Tool (E)"><i class="fas fa-eraser"></i> Eraser</button>
                    <button id="handTool" class="btn" title="Pan Tool (H)"><i class="fas fa-hand-paper"></i> Pan</button>
                    <button id="resetViewBtn" class="btn" title="Reset View (R)"><i class="fas fa-search-plus"></i> Reset View</button>
                </div>
                <div class="form-group">
                    <label for="strokeSize" class="form-label">Stroke Size: <span id="strokeSizeValue">10</span>px</label>
                    <input type="range" id="strokeSize" min="1" max="100" value="10">
                </div>
                <div class="form-group">
                    <label for="strokeColor" class="form-label">Stroke Color</label>
                    <input type="color" id="strokeColor" value="#000000">
                </div>
            </div>
            
            <div class="section" id="layersSection">
                <h2 class="section-title">Layers</h2>
                <div id="layersList" class="layers-list"></div>
                <div class="layer-actions">
                    <button id="addLayerBtn" class="btn btn-primary" title="Add New Layer"><i class="fas fa-plus-circle"></i> Add Layer</button>
                </div>
                <div id="selectedLayerOpacityControl" class="form-group hidden">
                    <label for="layerOpacity" class="form-label">Layer Opacity: <span id="layerOpacityValue">100</span>%</label>
                    <input type="range" id="layerOpacity" min="0" max="100" value="100">
                </div>
            </div>

            <div class="section">
                <h2 class="section-title">Animation Effects (Active Layer)</h2>
                <div class="form-group">
                    <label for="wiggleIntensity" class="form-label">Wiggle Intensity: <span id="wiggleIntensityValue">0</span></label>
                    <input type="range" id="wiggleIntensity" min="0" max="20" value="0" step="0.5">
                </div>
                <div class="form-group"> 
                    <label for="breathingStroke" class="form-label">Breathing Stroke: <span id="breathingStrokeValue">0</span></label>
                    <input type="range" id="breathingStroke" min="0" max="20" value="0" step="1">
                </div>
                <div class="form-group">
                    <label for="shakeIntensity" class="form-label">Shake Intensity: <span id="shakeIntensityValue">0</span></label>
                    <input type="range" id="shakeIntensity" min="0" max="10" value="0" step="0.5">
                </div>
                <div class="form-group">
                    <label for="animationSpeed" class="form-label">Animation Speed: <span id="animationSpeedValue">1</span>x</label>
                    <input type="range" id="animationSpeed" min="0.1" max="5" value="1" step="0.1">
                </div>
            </div>
        </aside>
    </div>

    <div id="messageModal" class="modal hidden">
        <div class="modal-content">
            <h2 id="modalTitle" class="modal-title">Notification</h2>
            <p id="modalMessage" class="modal-message">This is a message.</p>
            <div class="modal-button-container">
                <button id="modalCloseBtn" class="btn modal-button">Close</button>
            </div>
        </div>
    </div>

    <div id="loadingIndicator" class="loadingIndicator hidden">
        <div class="loading-content">
            <div class="spinner"></div>
            <span id="loadingText">Loading...</span> </div>
    </div>
    
    <footer class="footer">
        Created by Bixrail
    </footer>

    <script>
        // FFmpeg.wasm setup
        const { createFFmpeg, fetchFile } = FFmpeg;
        let ffmpeg; 

        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const penToolBtn = document.getElementById('penTool');
        const eraserToolBtn = document.getElementById('eraserTool');
        const handToolBtn = document.getElementById('handTool');
        const resetViewBtn = document.getElementById('resetViewBtn');

        const strokeSizeSlider = document.getElementById('strokeSize');
        const strokeSizeValue = document.getElementById('strokeSizeValue');
        const strokeColorPicker = document.getElementById('strokeColor');
        const clearActiveLayerBtn = document.getElementById('clearActiveLayerBtn');
        const clearAllLayersBtn = document.getElementById('clearAllLayersBtn');

        const animationSliders = {
            wiggleIntensity: { slider: document.getElementById('wiggleIntensity'), valueEl: document.getElementById('wiggleIntensityValue'), suffix: '' },
            breathingStroke: { slider: document.getElementById('breathingStroke'), valueEl: document.getElementById('breathingStrokeValue'), suffix: '' },
            shakeIntensity: { slider: document.getElementById('shakeIntensity'), valueEl: document.getElementById('shakeIntensityValue'), suffix: '' },
            animationSpeed: { slider: document.getElementById('animationSpeed'), valueEl: document.getElementById('animationSpeedValue'), suffix: 'x' }
        };

        const saveBtn = document.getElementById('saveBtn');
        const loadInput = document.getElementById('loadInput');
        const exportMp4Btn = document.getElementById('exportMp4Btn'); 
        const exportGifBtn = document.getElementById('exportGifBtn'); 
        const loadingIndicator = document.getElementById('loadingIndicator');
        const loadingText = document.getElementById('loadingText'); 
        
        const messageModal = document.getElementById('messageModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');

        const layersListContainer = document.getElementById('layersList');
        const addLayerBtn = document.getElementById('addLayerBtn');
        const selectedLayerOpacityControl = document.getElementById('selectedLayerOpacityControl');
        const layerOpacitySlider = document.getElementById('layerOpacity');
        const layerOpacityValue = document.getElementById('layerOpacityValue');
        
        const controlPanel = document.getElementById('controlPanel');
        const controlPanelToggle = document.getElementById('controlPanelToggle');

        let isDrawing = false;
        let currentTool = 'pen'; // 'pen', 'eraser', 'hand'
        let currentStrokeSize = 10;
        let currentStrokeColor = '#000000';
        
        let layers = [];
        let activeLayerId = null;

        let lastX, lastY; // For drawing, in world coordinates
        let animationFrameId;
        let time = 0; 
        let undoStack = [];
        let redoStack = [];

        const WORLD_WIDTH = 1920;
        const WORLD_HEIGHT = 1080;

        let viewTransform = {
            scale: 1,
            offsetX: 0, 
            offsetY: 0  
        };
        let isPanning = false;
        let panStartX, panStartY;
        const MIN_ZOOM = 0.1;
        const MAX_ZOOM = 10;

        const EXPORT_WIDTH = 1920; 
        const EXPORT_HEIGHT = 1080; 

        function generateLayerId() { return Date.now() + Math.random().toString(36).substr(2, 9); }
        function getActiveLayer() { return layers.find(layer => layer.id === activeLayerId); }

        function setActiveToolButton(activeBtn) {
            [penToolBtn, eraserToolBtn, handToolBtn].forEach(btn => btn.classList.remove('active-tool'));
            if (activeBtn) activeBtn.classList.add('active-tool');
            updateCanvasCursor(); 
        }
        
        function updateCanvasCursor() {
            const size = Math.max(2, currentStrokeSize * viewTransform.scale); 
            let cursorSVG;
            if (currentTool === 'pen') {
                cursorSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}"><circle cx="${size/2}" cy="${size/2}" r="${size/2}" fill="rgba(0,0,0,0.5)"/></svg>`;
                canvas.style.cursor = `url('data:image/svg+xml;utf8,${encodeURIComponent(cursorSVG)}') ${size/2} ${size/2}, auto`;
            } else if (currentTool === 'eraser') {
                const outlineWidth = Math.max(1, Math.min(2, size / 10)); 
                cursorSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}"><circle cx="${size/2}" cy="${size/2}" r="${size/2 - outlineWidth/2}" fill="rgba(255,255,255,0.5)" stroke="rgba(0,0,0,0.7)" stroke-width="${outlineWidth}"/></svg>`;
                canvas.style.cursor = `url('data:image/svg+xml;utf8,${encodeURIComponent(cursorSVG)}') ${size/2} ${size/2}, auto`;
            } else if (currentTool === 'hand') {
                canvas.style.cursor = isPanning ? 'grabbing' : 'grab';
            } else {
                canvas.style.cursor = 'default';
            }
        }

        function saveStateForUndo() {
            const state = { layers: JSON.parse(JSON.stringify(layers)), viewTransform: { ...viewTransform } };
            undoStack.push(state);
            if (undoStack.length > 30) undoStack.shift();
            redoStack = []; 
            updateUndoRedoButtons();
        }
        
        function updateUndoRedoButtons() {
            undoBtn.disabled = undoStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
            undoBtn.classList.toggle('btn-disabled', undoBtn.disabled);
            redoBtn.classList.toggle('btn-disabled', redoBtn.disabled);
        }

        function showModal(title, message, customButtons = null, isCustom = false) {
            modalTitle.textContent = title;
            modalMessage.innerHTML = message; 
            const buttonContainer = messageModal.querySelector('.modal-button-container');
            buttonContainer.innerHTML = ''; 
            if (isCustom && customButtons && customButtons.length > 0) {
                customButtons.forEach(btnConfig => {
                    const button = document.createElement('button');
                    button.textContent = btnConfig.text;
                    button.className = `btn modal-button ${btnConfig.class || 'btn-primary'}`;
                    button.onclick = btnConfig.action;
                    buttonContainer.appendChild(button);
                });
            } else {
                const closeButton = document.createElement('button');
                closeButton.className = 'btn modal-button btn-primary';
                closeButton.textContent = 'Close';
                closeButton.onclick = () => closeModal(messageModal);
                buttonContainer.appendChild(closeButton);
            }
            messageModal.classList.remove('hidden');
        }

        function closeModal(modalElement) { modalElement.classList.add('hidden'); }
        messageModal.addEventListener('click', (event) => { 
            if (event.target === messageModal || event.target.classList.contains('modal-button')) { 
                if (!event.target.classList.contains('btn-danger') && !event.target.classList.contains('btn-primary') && event.target.textContent !== 'Delete' && event.target.textContent !== 'Clear Layer' && event.target.textContent !== 'Clear All') {
                     closeModal(messageModal);
                }
            }
        });

        function setDefaultViewTransform() {
            const scaleX = canvas.width / WORLD_WIDTH;
            const scaleY = canvas.height / WORLD_HEIGHT;
            viewTransform.scale = Math.min(scaleX, scaleY); 

            viewTransform.offsetX = (canvas.width - WORLD_WIDTH * viewTransform.scale) / 2;
            viewTransform.offsetY = (canvas.height - WORLD_HEIGHT * viewTransform.scale) / 2;
        }


        function resizeCanvas() {
            const canvasContainer = canvas.parentElement;
            const style = getComputedStyle(canvasContainer);
            const paddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
            const paddingY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
            const containerWidth = canvasContainer.clientWidth - paddingX;
            const containerHeight = canvasContainer.clientHeight - paddingY;
            
            canvas.width = Math.max(10, containerWidth); 
            canvas.height = Math.max(10, containerHeight);
            
            if (viewTransform.scale === 1 && viewTransform.offsetX === 0 && viewTransform.offsetY === 0 && layers.length > 0) {
                 setDefaultViewTransform();
            }
            drawScene(); 
        }
        window.addEventListener('resize', resizeCanvas);
        
        controlPanelToggle.addEventListener('click', () => {
            controlPanel.classList.toggle('open');
            controlPanelToggle.innerHTML = controlPanel.classList.contains('open') ? '<i class="fas fa-times"></i>' : '<i class="fas fa-bars"></i>';
        });

        function createNewLayer(nameSuffix = layers.length + 1, strokes = [], customAnimationSettings = null, isVisible = true, opacity = 1, isActive = false) {
            const defaultAnimSettings = {};
            for (const key in animationSliders) {
                defaultAnimSettings[key] = parseFloat(animationSliders[key].slider.defaultValue || animationSliders[key].slider.value);
            }
            return {
                id: generateLayerId(), name: `Layer ${nameSuffix}`, strokes: strokes,
                animationSettings: customAnimationSettings || defaultAnimSettings,
                isVisible: isVisible, opacity: opacity, isActive: isActive 
            };
        }

        function addLayer() {
            saveStateForUndo();
            const newLayer = createNewLayer(layers.length + 1);
            const activeLayerIndex = layers.findIndex(l => l.id === activeLayerId);
            if (activeLayerIndex !== -1 && activeLayerIndex < layers.length -1) layers.splice(activeLayerIndex + 1, 0, newLayer);
            else layers.push(newLayer); 
            setActiveLayer(newLayer.id); 
            renderLayersList();
            updateAnimationSlidersForActiveLayer();
        }

        function setActiveLayer(layerId) {
            const previouslyActiveLayer = getActiveLayer();
            if (previouslyActiveLayer) previouslyActiveLayer.isActive = false;
            activeLayerId = layerId;
            const currentActiveLayer = getActiveLayer();
            if (currentActiveLayer) {
                currentActiveLayer.isActive = true;
                layerOpacitySlider.value = currentActiveLayer.opacity * 100;
                layerOpacityValue.textContent = Math.round(currentActiveLayer.opacity * 100);
                selectedLayerOpacityControl.classList.remove('hidden');
            } else selectedLayerOpacityControl.classList.add('hidden');
            renderLayersList(); 
            updateAnimationSlidersForActiveLayer();
        }
        
        layerOpacitySlider.addEventListener('input', (e) => {
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                activeLayer.opacity = parseFloat(e.target.value) / 100;
                layerOpacityValue.textContent = e.target.value;
                drawScene(); 
            }
        });

        function renderLayersList() {
            layersListContainer.innerHTML = ''; 
            if (layers.length === 0) {
                layersListContainer.innerHTML = '<p class="text-gray-500 text-sm p-2 text-center">No layers yet.</p>';
                selectedLayerOpacityControl.classList.add('hidden'); return;
            }
            [...layers].reverse().forEach((layer, R_index) => { 
                const index = layers.length - 1 - R_index; 
                const item = document.createElement('div');
                item.className = `layer-item ${layer.id === activeLayerId ? 'active-layer' : ''}`;
                item.dataset.layerId = layer.id;
                const visibilityBtn = document.createElement('button');
                visibilityBtn.className = 'btn btn-sm';
                visibilityBtn.innerHTML = `<i class="fas ${layer.isVisible ? 'fa-eye' : 'fa-eye-slash'}"></i>`;
                visibilityBtn.title = layer.isVisible ? "Hide" : "Show";
                visibilityBtn.onclick = (e) => { e.stopPropagation(); toggleLayerVisibility(layer.id); };
                const nameSpan = document.createElement('span');
                nameSpan.className = 'layer-name'; nameSpan.textContent = layer.name; nameSpan.title = "Rename";
                nameSpan.ondblclick = (e) => { e.stopPropagation(); makeLayerNameEditable(layer.id, nameSpan); };
                const controlsDiv = document.createElement('div'); controlsDiv.className = 'layer-controls';
                const upBtn = document.createElement('button'); upBtn.className = 'btn btn-sm'; upBtn.innerHTML = '<i class="fas fa-arrow-up"></i>'; upBtn.title = "Up";
                upBtn.disabled = index === layers.length - 1; upBtn.onclick = (e) => { e.stopPropagation(); moveLayer(layer.id, 'up'); };
                if(upBtn.disabled) upBtn.classList.add('btn-disabled');
                const downBtn = document.createElement('button'); downBtn.className = 'btn btn-sm'; downBtn.innerHTML = '<i class="fas fa-arrow-down"></i>'; downBtn.title = "Down";
                downBtn.disabled = index === 0; downBtn.onclick = (e) => { e.stopPropagation(); moveLayer(layer.id, 'down'); };
                if(downBtn.disabled) downBtn.classList.add('btn-disabled');
                const deleteBtn = document.createElement('button'); deleteBtn.className = 'btn btn-sm btn-danger'; deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>'; deleteBtn.title = "Delete";
                deleteBtn.onclick = (e) => { e.stopPropagation(); deleteLayer(layer.id); };
                controlsDiv.append(upBtn, downBtn, deleteBtn); item.append(visibilityBtn, nameSpan, controlsDiv);
                item.onclick = () => setActiveLayer(layer.id); layersListContainer.appendChild(item);
            });
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                selectedLayerOpacityControl.classList.remove('hidden');
                layerOpacitySlider.value = activeLayer.opacity * 100;
                layerOpacityValue.textContent = Math.round(activeLayer.opacity * 100);
            } else selectedLayerOpacityControl.classList.add('hidden');
        }
        
        function makeLayerNameEditable(layerId, nameSpan) {
            const layer = layers.find(l => l.id === layerId); if (!layer) return;
            const input = document.createElement('input'); input.type = 'text'; input.className = 'layer-name-input'; input.value = layer.name;
            nameSpan.replaceWith(input); input.focus(); input.select();
            const saveName = () => {
                saveStateForUndo(); layer.name = input.value.trim() || `Layer ${layers.findIndex(l => l.id === layerId) + 1}`;
                input.replaceWith(nameSpan); nameSpan.textContent = layer.name; 
            };
            input.onblur = saveName; input.onkeydown = (e) => { if (e.key === 'Enter') input.blur(); else if (e.key === 'Escape') { input.value = layer.name; input.blur(); }};
        }

        function toggleLayerVisibility(layerId) {
            saveStateForUndo(); const layer = layers.find(l => l.id === layerId);
            if (layer) layer.isVisible = !layer.isVisible; renderLayersList(); drawScene();
        }

        function deleteLayer(layerId) {
            if (layers.length <= 1) { showModal("Action Denied", "Cannot delete the last layer."); return; }
            const layerToDelete = layers.find(l => l.id === layerId); if (!layerToDelete) return;
            showModal("Confirm Deletion", `Delete layer "${layerToDelete.name}"?`, 
            [{ text: "Delete", class: 'btn-danger', action: () => {
                saveStateForUndo(); layers = layers.filter(l => l.id !== layerId);
                if (activeLayerId === layerId) setActiveLayer(layers.length > 0 ? layers[layers.length - 1].id : null);
                renderLayersList(); drawScene(); closeModal(messageModal);
            }},{ text: "Cancel", class: 'btn', action: () => closeModal(messageModal) }], true);
        }

        function moveLayer(layerId, direction) {
            saveStateForUndo(); const index = layers.findIndex(l => l.id === layerId); if (index === -1) return;
            if (direction === 'up' && index < layers.length - 1) [layers[index], layers[index + 1]] = [layers[index + 1], layers[index]];
            else if (direction === 'down' && index > 0) [layers[index], layers[index - 1]] = [layers[index - 1], layers[index]];
            renderLayersList(); drawScene();
        }

        function updateAnimationSlidersForActiveLayer() {
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                for (const key in animationSliders) {
                    const setting = activeLayer.animationSettings[key];
                    if (setting !== undefined) {
                        animationSliders[key].slider.value = setting;
                        animationSliders[key].valueEl.textContent = setting + (animationSliders[key].suffix || '');
                    }
                }
            } else {
                 for (const key in animationSliders) {
                    animationSliders[key].slider.value = animationSliders[key].slider.defaultValue || 0;
                    animationSliders[key].valueEl.textContent = (animationSliders[key].slider.defaultValue || 0) + (animationSliders[key].suffix || '');
                 }
            }
        }

        Object.values(animationSliders).forEach(item => {
            item.slider.addEventListener('input', (e) => {
                const activeLayer = getActiveLayer();
                if (activeLayer) {
                    const key = Object.keys(animationSliders).find(k => animationSliders[k].slider === e.target);
                    if (key) {
                        activeLayer.animationSettings[key] = parseFloat(e.target.value);
                        item.valueEl.textContent = e.target.value + (item.suffix || '');
                    }
                }
            });
        });
        
        // --- Canvas View Transformation ---
        function getCanvasMousePos(e) { // Gets mouse/touch relative to canvas element
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        function getTransformedMousePos(e) { // Converts screen/canvas pos to world pos
            const { x: canvasX, y: canvasY } = getCanvasMousePos(e);
            return {
                x: (canvasX - viewTransform.offsetX) / viewTransform.scale,
                y: (canvasY - viewTransform.offsetY) / viewTransform.scale
            };
        }

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            saveStateForUndo(); 

            const { x: mouseX, y: mouseY } = getCanvasMousePos(e); // Mouse pos relative to canvas element

            const zoomIntensity = 0.1;
            const delta = e.deltaY > 0 ? -zoomIntensity : zoomIntensity;
            const newScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, viewTransform.scale * (1 + delta)));

            // Adjust offset to zoom towards the mouse point
            viewTransform.offsetX = mouseX - (mouseX - viewTransform.offsetX) * (newScale / viewTransform.scale);
            viewTransform.offsetY = mouseY - (mouseY - viewTransform.offsetY) * (newScale / viewTransform.scale);
            viewTransform.scale = newScale;
            
            updateCanvasCursor(); // Cursor size might change with zoom
            drawScene();
        }, { passive: false });

        let lastPinchDist = null;
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) { 
                e.preventDefault();
                isPanning = false; 
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastPinchDist = Math.sqrt(dx * dx + dy * dy);
                saveStateForUndo(); 
            } else if (e.touches.length === 1 && currentTool === 'hand') {
                isPanning = true;
                const { x: canvasX, y: canvasY } = getCanvasMousePos(e);
                panStartX = canvasX - viewTransform.offsetX;
                panStartY = canvasY - viewTransform.offsetY;
                canvas.style.cursor = 'grabbing';
                saveStateForUndo();
            } else if (e.touches.length === 1 && (currentTool === 'pen' || currentTool === 'eraser')) {
                 startDrawing(e); // Allow drawing to start on touch
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && lastPinchDist !== null) {
                e.preventDefault();
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const currentPinchDist = Math.sqrt(dx * dx + dy * dy);
                const scaleChange = currentPinchDist / lastPinchDist;
                
                const { x: pinchCenterX, y: pinchCenterY } = getCanvasMousePos({ 
                    clientX: (e.touches[0].clientX + e.touches[1].clientX) / 2, 
                    clientY: (e.touches[0].clientY + e.touches[1].clientY) / 2 
                });

                const newScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, viewTransform.scale * scaleChange));
                viewTransform.offsetX = pinchCenterX - (pinchCenterX - viewTransform.offsetX) * (newScale / viewTransform.scale);
                viewTransform.offsetY = pinchCenterY - (pinchCenterY - viewTransform.offsetY) * (newScale / viewTransform.scale);
                viewTransform.scale = newScale;
                lastPinchDist = currentPinchDist;
                updateCanvasCursor(); drawScene();
            } else if (e.touches.length === 1 && currentTool === 'hand' && isPanning) {
                e.preventDefault();
                const { x: canvasX, y: canvasY } = getCanvasMousePos(e);
                viewTransform.offsetX = canvasX - panStartX;
                viewTransform.offsetY = canvasY - panStartY;
                drawScene();
            } else if (e.touches.length === 1 && isDrawing && (currentTool === 'pen' || currentTool === 'eraser')) {
                draw(e); // Allow drawing to continue on touch
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) lastPinchDist = null;
            if (e.touches.length < 1 && currentTool === 'hand' && isPanning) {
                isPanning = false;
                canvas.style.cursor = 'grab';
            }
             if (e.touches.length < 1 && isDrawing) { // If drawing was active
                stopDrawing();
            }
        });


        resetViewBtn.addEventListener('click', () => {
            saveStateForUndo();
            setDefaultViewTransform();
            updateCanvasCursor(); 
            drawScene();
        });


        // --- Drawing Logic (Layer-aware & View Transformed) ---
        function startDrawing(e) {
            // console.log("startDrawing called. Tool:", currentTool);
            if (currentTool !== 'pen' && currentTool !== 'eraser') {
                // console.log("startDrawing: Not pen or eraser tool.");
                return;
            }
            const activeLayer = getActiveLayer();
            if (!activeLayer) { 
                // console.error("startDrawing: No active layer!"); 
                return; 
            }
            if (!activeLayer.isVisible) {
                // console.log("startDrawing: Active layer is not visible.");
                return;
            }
            if (e.button !== 0 && e.type === 'mousedown') {
                // console.log("startDrawing: Not main mouse button.");
                return; // Only main mouse button
            }
            
            saveStateForUndo(); 
            isDrawing = true;
            const { x, y } = getTransformedMousePos(e); 
            // console.log(`startDrawing: Starting at world coords (${x.toFixed(2)}, ${y.toFixed(2)}) on layer ${activeLayer.name}`);
            
            if (currentTool === 'pen') {
                activeLayer.strokes.push({
                    id: generateLayerId(), 
                    points: [{ x: x, y: y }],
                    color: currentStrokeColor, 
                    size: currentStrokeSize, 
                    tool: currentTool, 
                    originalSize: currentStrokeSize,
                    birthTime: time, 
                });
                // console.log("startDrawing: Pen stroke added to layer:", activeLayer.strokes[activeLayer.strokes.length -1]);
            }
            // For eraser, we just need to set the starting point for path checking during the 'draw' (mousemove/touchmove) event.
            lastX = x; lastY = y; 
        }

        // Helper for eraser: point in circle check
        function isPointInCircle(px, py, cx, cy, radius) {
            const dx = px - cx;
            const dy = py - cy;
            return dx * dx + dy * dy <= radius * radius;
        }


        function draw(e) {
            // console.log("draw called. isDrawing:", isDrawing, "Tool:", currentTool);
            const activeLayer = getActiveLayer();
            if (!isDrawing || !activeLayer || !activeLayer.isVisible) {
                // if(!isDrawing) console.log("draw: Not drawing.");
                // if(!activeLayer) console.error("draw: No active layer!");
                // if(activeLayer && !activeLayer.isVisible) console.log("draw: Active layer not visible.");
                return;
            }

            const { x, y } = getTransformedMousePos(e); 

            if (currentTool === 'eraser') {
                // console.log(`Eraser at world coords (${x.toFixed(2)}, ${y.toFixed(2)})`);
                const eraserRadiusWorld = currentStrokeSize / 2; 
                let erasedSomething = false;
                for (let i = activeLayer.strokes.length - 1; i >= 0; i--) {
                    const stroke = activeLayer.strokes[i];
                    if (stroke.tool === 'pen') { 
                        let hit = false;
                        for (const p of stroke.points) {
                            if (isPointInCircle(p.x, p.y, x, y, eraserRadiusWorld)) {
                                hit = true;
                                break;
                            }
                        }
                        if (hit) {
                            // console.log("Eraser hit stroke:", stroke.id);
                            activeLayer.strokes.splice(i, 1); 
                            erasedSomething = true;
                        }
                    }
                }
                if (erasedSomething) {
                    // console.log("Eraser removed strokes, redrawing scene.");
                    drawScene(); 
                }
                lastX = x; lastY = y; 

            } else if (currentTool === 'pen') {
                const currentPath = activeLayer.strokes[activeLayer.strokes.length - 1];
                if (!currentPath || currentPath.tool !== 'pen') { 
                    // console.error("draw (pen): No current path or path is not a pen stroke.");
                    isDrawing = false; 
                    return; 
                }
                currentPath.points.push({ x: x, y: y });
                // console.log(`Pen drawing: Added point (${x.toFixed(2)}, ${y.toFixed(2)}) to stroke ${currentPath.id}`);
            
                ctx.save();
                ctx.translate(viewTransform.offsetX, viewTransform.offsetY);
                ctx.scale(viewTransform.scale, viewTransform.scale);
                ctx.globalAlpha = activeLayer.opacity; 
                ctx.globalCompositeOperation = 'source-over';

                ctx.beginPath();
                ctx.moveTo(lastX, lastY); 
                ctx.lineTo(x, y);         
                ctx.strokeStyle = currentPath.color;
                ctx.lineWidth = currentPath.size / viewTransform.scale; 
                ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                ctx.stroke();
                ctx.restore();
                lastX = x; lastY = y; 
            }
        }

        function stopDrawing() { 
            // console.log("stopDrawing called. Tool:", currentTool, "isDrawing:", isDrawing);
            if (currentTool !== 'pen' && currentTool !== 'eraser') return;
            if (isDrawing) {
                isDrawing = false;
                if(currentTool === 'eraser') {
                    // console.log("stopDrawing (eraser): Final redraw after erasing.");
                    drawScene();
                }
                // console.log("Drawing stopped.");
            }
        }

        // Pan (Hand Tool) Logic
        handToolBtn.addEventListener('click', () => { currentTool = 'hand'; setActiveToolButton(handToolBtn); });

        canvas.addEventListener('mousedown', (e) => {
            if (currentTool === 'hand' && e.button === 0) {
                isPanning = true;
                const { x: canvasX, y: canvasY } = getCanvasMousePos(e);
                panStartX = canvasX - viewTransform.offsetX;
                panStartY = canvasY - viewTransform.offsetY;
                canvas.style.cursor = 'grabbing';
                saveStateForUndo(); 
            } else if (currentTool === 'pen' || currentTool === 'eraser') { // Ensure drawing starts on mousedown too
                startDrawing(e);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (currentTool === 'hand' && isPanning) {
                const { x: canvasX, y: canvasY } = getCanvasMousePos(e);
                viewTransform.offsetX = canvasX - panStartX;
                viewTransform.offsetY = canvasY - panStartY;
                drawScene();
            } else if (isDrawing && (currentTool === 'pen' || currentTool === 'eraser')) { // Ensure drawing continues on mousemove
                draw(e);
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (currentTool === 'hand' && isPanning) {
                isPanning = false;
                canvas.style.cursor = 'grab';
            } else if (isDrawing) { // Ensure drawing stops on mouseup
                stopDrawing();
            }
        });
        canvas.addEventListener('mouseleave', () => { 
            if (currentTool === 'hand' && isPanning) {
                isPanning = false;
                canvas.style.cursor = 'grab';
            } else if (isDrawing) { // Ensure drawing stops if mouse leaves
                stopDrawing();
            }
        });


        penToolBtn.addEventListener('click', () => { currentTool = 'pen'; setActiveToolButton(penToolBtn); });
        eraserToolBtn.addEventListener('click', () => { currentTool = 'eraser'; setActiveToolButton(eraserToolBtn); });

        strokeSizeSlider.addEventListener('input', (e) => { 
            currentStrokeSize = parseInt(e.target.value); 
            strokeSizeValue.textContent = currentStrokeSize; 
            updateCanvasCursor();
        });
        strokeColorPicker.addEventListener('input', (e) => { currentStrokeColor = e.target.value; });
        
        clearActiveLayerBtn.addEventListener('click', () => { 
            const activeLayer = getActiveLayer();
            if (!activeLayer || activeLayer.strokes.length === 0) {
                showModal("Clear Layer", "Active layer is already empty.");
                return;
            }
            showModal("Confirm Clear Layer", `Clear all strokes from layer "${activeLayer.name}"?`,
            [{text: "Clear Layer", class: 'btn-danger', action: () => {
                saveStateForUndo(); 
                activeLayer.strokes = []; 
                drawScene(); closeModal(messageModal);
            }},{text: "Cancel", class: 'btn', action: () => closeModal(messageModal)}], true);
        });
        
        clearAllLayersBtn.addEventListener('click', () => {
            if (layers.every(l => l.strokes.length === 0)) {
                 showModal("Clear All Layers", "All layers are already empty.");
                return;
            }
            showModal("Confirm Clear All", "Clear strokes from ALL layers? This action affects all layers.",
            [{text: "Clear All", class: 'btn-danger', action: () => {
                saveStateForUndo(); 
                layers.forEach(layer => layer.strokes = []); 
                drawScene(); closeModal(messageModal);
            }},{text: "Cancel", class: 'btn', action: () => closeModal(messageModal)}], true);
        });


        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');

        undoBtn.addEventListener('click', () => {
            if (undoStack.length > 0) {
                redoStack.push({ layers: JSON.parse(JSON.stringify(layers)), viewTransform: { ...viewTransform } });
                const prevState = undoStack.pop();
                layers = prevState.layers;
                viewTransform = prevState.viewTransform;
                
                const currentActiveStillExists = layers.find(l => l.id === activeLayerId);
                if (!currentActiveStillExists && layers.length > 0) activeLayerId = layers[layers.length - 1].id;
                else if (layers.length === 0) activeLayerId = null;
                layers.forEach(l => l.isActive = (l.id === activeLayerId));

                renderLayersList(); updateAnimationSlidersForActiveLayer(); drawScene(); updateUndoRedoButtons();
            }
        });

        redoBtn.addEventListener('click', () => {
            if (redoStack.length > 0) {
                undoStack.push({ layers: JSON.parse(JSON.stringify(layers)), viewTransform: { ...viewTransform } });
                const nextState = redoStack.pop();
                layers = nextState.layers;
                viewTransform = nextState.viewTransform;

                const currentActiveStillExists = layers.find(l => l.id === activeLayerId);
                if (!currentActiveStillExists && layers.length > 0) activeLayerId = layers[layers.length - 1].id;
                else if (layers.length === 0) activeLayerId = null;
                layers.forEach(l => l.isActive = (l.id === activeLayerId));

                renderLayersList(); updateAnimationSlidersForActiveLayer(); drawScene(); updateUndoRedoButtons();
            }
        });

        function drawScene(isExporting = false, exportTimeOverride = null) {
            const currentTime = isExporting ? exportTimeOverride : time;
            const targetCtx = ctx; 
            
            const currentCanvasWidth = isExporting ? EXPORT_WIDTH : canvas.width;
            const currentCanvasHeight = isExporting ? EXPORT_HEIGHT : canvas.height;

            targetCtx.save(); 
            if (isExporting) {
                if(canvas.width !== EXPORT_WIDTH || canvas.height !== EXPORT_HEIGHT) {
                    canvas.width = EXPORT_WIDTH;
                    canvas.height = EXPORT_HEIGHT;
                }
            }

            targetCtx.fillStyle = '#FFFFFF'; 
            targetCtx.fillRect(0, 0, currentCanvasWidth, currentCanvasHeight);

            if (!isExporting) {
                targetCtx.translate(viewTransform.offsetX, viewTransform.offsetY);
                targetCtx.scale(viewTransform.scale, viewTransform.scale);
            }

            layers.forEach(layer => {
                if (!layer.isVisible || layer.strokes.length === 0) return;
                targetCtx.save(); 
                targetCtx.globalAlpha = layer.opacity; 
                const animSettings = layer.animationSettings;
                const animSpeed = parseFloat(animSettings.animationSpeed); 
                const wiggleAmp = parseFloat(animSettings.wiggleIntensity);
                const breathAmount = parseFloat(animSettings.breathingStroke);
                const shakeAmount = parseFloat(animSettings.shakeIntensity);

                layer.strokes.forEach(stroke => {
                    if (!stroke.points || stroke.points.length < 1) return;
                    targetCtx.save(); 

                    if (shakeAmount > 0) { 
                        const shakeX = (Math.random() - 0.5) * shakeAmount * animSpeed; 
                        const shakeY = (Math.random() - 0.5) * shakeAmount * animSpeed;
                        targetCtx.translate(shakeX, shakeY);
                    }

                    let currentDynamicSize = stroke.originalSize;
                    if (breathAmount > 0) {
                        currentDynamicSize = stroke.originalSize + Math.sin(currentTime * 0.1 * animSpeed + stroke.birthTime) * breathAmount;
                        currentDynamicSize = Math.max(1, currentDynamicSize);
                    }
                    
                    if (stroke.tool === 'pen') {
                        targetCtx.globalCompositeOperation = 'source-over';
                        targetCtx.beginPath();
                        if (stroke.points.length === 1) { 
                            const p = stroke.points[0];
                            const radius = (currentDynamicSize / 2) / (isExporting ? 1 : viewTransform.scale);
                            targetCtx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                            targetCtx.fillStyle = stroke.color; 
                            targetCtx.fill();
                        } else { 
                            for (let i = 0; i < stroke.points.length; i++) {
                                let p = { ...stroke.points[i] }; 
                                if (wiggleAmp > 0 && i > 0) {
                                    const prevP = stroke.points[i-1]; const dx = p.x - prevP.x; const dy = p.y - prevP.y;
                                    const angle = Math.atan2(dy, dx); const normalAngle = angle + Math.PI / 2; 
                                    const wiggleOffset = Math.sin(currentTime * 0.1 * animSpeed + i * 0.5 + stroke.birthTime * 0.01) * wiggleAmp;
                                    p.x += Math.cos(normalAngle) * wiggleOffset; p.y += Math.sin(normalAngle) * wiggleOffset;
                                }
                                if (i === 0) targetCtx.moveTo(p.x, p.y); else targetCtx.lineTo(p.x, p.y);
                            }
                            targetCtx.strokeStyle = stroke.color;
                            targetCtx.lineWidth = currentDynamicSize / (isExporting ? 1 : viewTransform.scale);
                            targetCtx.lineCap = 'round'; targetCtx.lineJoin = 'round'; 
                            targetCtx.stroke();
                        }
                    }
                    targetCtx.restore(); 
                });
                targetCtx.restore(); 
            });
            if (!isExporting) targetCtx.restore(); 
        }

        function animate() { time += 1; drawScene(); animationFrameId = requestAnimationFrame(animate); }
        
        strokeSizeSlider.addEventListener('input', (e) => { 
            currentStrokeSize = parseInt(e.target.value); 
            strokeSizeValue.textContent = currentStrokeSize; 
            updateCanvasCursor();
        });

        saveBtn.addEventListener('click', () => {
            if (layers.length === 0 || layers.every(l => l.strokes.length === 0)) { showModal("Save Sketch", "Canvas empty."); return; }
            const dataToSave = { layers: layers, activeLayerId: activeLayerId, WORLD_WIDTH, WORLD_HEIGHT, viewTransform }; 
            const jsonData = JSON.stringify(dataToSave); const blob = new Blob([jsonData], { type: 'application/octet-stream' }); 
            const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url;
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-'); a.download = `drawerz_sketch_${timestamp}.drz`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            showModal("Save Sketch", "Sketch saved as .drz file!");
        });

        loadInput.addEventListener('change', (e) => {
            const file = e.target.files[0]; 
            if (!file) return;

            const fileName = file.name.toLowerCase();
            const fileExtension = fileName.split('.').pop();

            if (fileExtension === 'drz') {
                loadingIndicator.classList.remove('hidden'); 
                if(loadingText) loadingText.textContent = "Loading .drz sketch...";
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (data.layers && Array.isArray(data.layers)) {
                            saveStateForUndo(); 
                            layers = data.layers.map(loadedLayer => {
                                const defaultAnim = {};
                                for (const key in animationSliders) defaultAnim[key] = parseFloat(animationSliders[key].slider.defaultValue || 0);
                                return {
                                    id: loadedLayer.id || generateLayerId(), name: loadedLayer.name || 'Loaded Layer',
                                    strokes: loadedLayer.strokes || [],
                                    animationSettings: { ...defaultAnim, ...(loadedLayer.animationSettings || {}) }, 
                                    isVisible: loadedLayer.isVisible !== undefined ? loadedLayer.isVisible : true,
                                    opacity: loadedLayer.opacity !== undefined ? loadedLayer.opacity : 1, isActive: false
                                };
                            });
                            if (data.activeLayerId && layers.find(l => l.id === data.activeLayerId)) activeLayerId = data.activeLayerId;
                            else if (layers.length > 0) activeLayerId = layers[layers.length - 1].id;
                            else activeLayerId = null;
                            layers.forEach(l => l.isActive = (l.id === activeLayerId));
                            
                            if(data.viewTransform) viewTransform = data.viewTransform; else setDefaultViewTransform();
                            
                            renderLayersList(); updateAnimationSlidersForActiveLayer(); resizeCanvas(); 
                            showModal("Load Sketch", "Sketch loaded!");
                        } else showModal("Load Error", "Invalid .drz file. Missing 'layers' data.");
                    } catch (error) { console.error("Load error:", error); showModal("Load Error", "Could not load sketch. " + error.message);
                    } finally { loadingIndicator.classList.add('hidden'); loadInput.value = ''; }
                };
                reader.onerror = () => { showModal("Load Error", "Error reading file."); loadingIndicator.classList.add('hidden'); loadInput.value = ''; };
                reader.readAsText(file);
            } else if (fileExtension === 'svg') {
                loadingIndicator.classList.remove('hidden');
                if(loadingText) loadingText.textContent = "Parsing SVG...";
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        parseAndAddSVG(event.target.result);
                        showModal("SVG Import", "SVG content imported to active layer. Complex features might be simplified.");
                    } catch (error) {
                        console.error("SVG Parse error:", error);
                        showModal("SVG Import Error", "Could not parse SVG. " + error.message);
                    } finally {
                        loadingIndicator.classList.add('hidden');
                        loadInput.value = '';
                    }
                };
                reader.onerror = () => { showModal("Load Error", "Error reading SVG file."); loadingIndicator.classList.add('hidden'); loadInput.value = ''; };
                reader.readAsText(file);
            } else if (fileExtension === 'psd' || fileExtension === 'clip') { 
                 showModal("Import Not Supported", 
                    `Direct import of <strong>.${fileExtension.toUpperCase()}</strong> files is not supported due to their complexity. ` +
                    "Please export your artwork as an SVG from Photoshop or Clip Studio Paint if you wish to import vector data."
                );
                loadInput.value = ''; 
            } else {
                showModal("Unsupported File", "Unsupported file type. Please load a .drz or .svg file.");
                loadInput.value = ''; 
            }
        });

        function parseAndAddSVG(svgString) {
            const activeLayer = getActiveLayer();
            if (!activeLayer) {
                showModal("SVG Import Error", "No active layer to import SVG content into. Please add or select a layer.");
                return;
            }
            saveStateForUndo();

            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgString, "image/svg+xml");
            const svgElement = svgDoc.documentElement;

            let vbX=0, vbY=0, vbW=parseFloat(svgElement.getAttribute('width')), vbH=parseFloat(svgElement.getAttribute('height'));
            const viewBox = svgElement.getAttribute('viewBox');
            if (viewBox) {
                const parts = viewBox.split(/[\s,]+/);
                vbX = parseFloat(parts[0]) || 0;
                vbY = parseFloat(parts[1]) || 0;
                vbW = parseFloat(parts[2]) || vbW;
                vbH = parseFloat(parts[3]) || vbH;
            }
            
            const scaleX = WORLD_WIDTH / vbW; 
            const scaleY = WORLD_HEIGHT / vbH;
            const globalScale = Math.min(scaleX, scaleY) * 0.9; 

            function transformPoint(x, y) {
                return {
                    x: (x - vbX) * globalScale + (WORLD_WIDTH - vbW * globalScale) / 2,
                    y: (y - vbY) * globalScale + (WORLD_HEIGHT - vbH * globalScale) / 2
                };
            }
            
            let importedStrokesCount = 0;

            function parsePathD(d) {
                const points = [];
                if (!d) return points;
                const commands = d.match(/[a-zA-Z][^a-zA-Z]*/g) || [];
                let currentX = 0, currentY = 0;
                let subPathStart = null;

                commands.forEach(cmdStr => {
                    const type = cmdStr[0];
                    const args = (cmdStr.substring(1).match(/-?\d*\.?\d+/g) || []).map(parseFloat);
                    
                    if (type === 'M') { 
                        currentX = args[0]; currentY = args[1];
                        points.push(transformPoint(currentX, currentY));
                        subPathStart = {x: currentX, y: currentY};
                        for (let i = 2; i < args.length; i += 2) { 
                            currentX = args[i]; currentY = args[i+1];
                            points.push(transformPoint(currentX, currentY));
                        }
                    } else if (type === 'L') { 
                         for (let i = 0; i < args.length; i += 2) {
                            currentX = args[i]; currentY = args[i+1];
                            points.push(transformPoint(currentX, currentY));
                        }
                    } else if (type === 'Z' || type === 'z') { 
                        if (subPathStart && points.length > 0) {
                            const lastPoint = points[points.length-1];
                            const firstTransformed = transformPoint(subPathStart.x, subPathStart.y);
                            if(Math.abs(lastPoint.x - firstTransformed.x) > 0.1 || Math.abs(lastPoint.y - firstTransformed.y) > 0.1) { 
                                points.push(firstTransformed);
                            }
                        }
                        subPathStart = null; 
                    }
                });
                return points;
            }

            svgDoc.querySelectorAll('path, line, rect, circle, ellipse, polyline, polygon').forEach(el => {
                let points = [];
                const strokeColor = el.getAttribute('stroke') || currentStrokeColor;
                let strokeWidth = parseFloat(el.getAttribute('stroke-width')) || currentStrokeSize;
                if (isNaN(strokeWidth) || strokeWidth <= 0) strokeWidth = currentStrokeSize;

                const tagName = el.tagName.toLowerCase();
                if (tagName === 'path') {
                    points = parsePathD(el.getAttribute('d'));
                } else if (tagName === 'line') {
                    points.push(transformPoint(parseFloat(el.getAttribute('x1')), parseFloat(el.getAttribute('y1'))));
                    points.push(transformPoint(parseFloat(el.getAttribute('x2')), parseFloat(el.getAttribute('y2'))));
                } else if (tagName === 'rect') {
                    const x = parseFloat(el.getAttribute('x')); const y = parseFloat(el.getAttribute('y'));
                    const w = parseFloat(el.getAttribute('width')); const h = parseFloat(el.getAttribute('height'));
                    points.push(transformPoint(x, y)); points.push(transformPoint(x + w, y));
                    points.push(transformPoint(x + w, y + h)); points.push(transformPoint(x, y + h));
                    points.push(transformPoint(x, y)); 
                } else if (tagName === 'circle') {
                    const cx = parseFloat(el.getAttribute('cx')); const cy = parseFloat(el.getAttribute('cy'));
                    const r = parseFloat(el.getAttribute('r'));
                    for (let i = 0; i <= 360; i += 15) { 
                        const angle = i * Math.PI / 180;
                        points.push(transformPoint(cx + r * Math.cos(angle), cy + r * Math.sin(angle)));
                    }
                } else if (tagName === 'ellipse') {
                    const cx = parseFloat(el.getAttribute('cx')); const cy = parseFloat(el.getAttribute('cy'));
                    const rx = parseFloat(el.getAttribute('rx')); const ry = parseFloat(el.getAttribute('ry'));
                    for (let i = 0; i <= 360; i += 15) {
                        const angle = i * Math.PI / 180;
                        points.push(transformPoint(cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)));
                    }
                } else if (tagName === 'polyline' || tagName === 'polygon') {
                    const ptsStr = el.getAttribute('points').split(/[\s,]+/);
                    for (let i = 0; i < ptsStr.length; i += 2) {
                        points.push(transformPoint(parseFloat(ptsStr[i]), parseFloat(ptsStr[i+1])));
                    }
                    if (tagName === 'polygon' && points.length > 0) {
                        points.push({...points[0]}); 
                    }
                }

                if (points.length > 0) {
                    activeLayer.strokes.push({
                        id: generateLayerId(), points: points, color: strokeColor, size: strokeWidth,
                        tool: 'pen', originalSize: strokeWidth, birthTime: time 
                    });
                    importedStrokesCount++;
                }
            });
            if (importedStrokesCount > 0) drawScene();
            console.log(`Imported ${importedStrokesCount} shapes/paths from SVG.`);
        }
        
        async function initializeFFmpeg() {
            if (!ffmpeg) { 
                 ffmpeg = createFFmpeg({ 
                    log: true, 
                    corePath: 'https://unpkg.com/@ffmpeg/core@0.11.0/dist/ffmpeg-core.js',
                 });
            }
            if (!ffmpeg.isLoaded()) {
                if(loadingText) loadingText.textContent = "Loading FFmpeg library (~30MB)...";
                loadingIndicator.classList.remove('hidden'); 
                await ffmpeg.load();
            }
        }

        async function checkAndLoadFFmpeg() {
            if (typeof SharedArrayBuffer === 'undefined') {
                let sabMessage = "<p>MP4 export uses FFmpeg.wasm, which requires <code>SharedArrayBuffer</code>.</p>" +
                                 "<p>This feature is often disabled by browsers unless the page is served with specific HTTP headers (COOP & COEP).</p>";
                if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                sabMessage += "<p>A Service Worker is active, which attempts to set these headers. If <code>SharedArrayBuffer</code> is still unavailable, please try **reloading the page** (sometimes a hard refresh: Ctrl+Shift+R or Cmd+Shift+R is needed). If the issue persists, your hosting environment or browser settings might be preventing it.</p>";
                } else if ('serviceWorker' in navigator) {
                sabMessage += "<p>A Service Worker is attempting to register to enable this. This might be its first activation. Please **reload the page** and try exporting again. If MP4 export still fails, the Service Worker might not have activated correctly or your environment has restrictions.</p>";
                } else {
                sabMessage += "<p>Your browser does not support Service Workers, or support is disabled. Service Workers are used here to attempt to set the required headers on this hosting platform.</p>";
                }
                sabMessage += "<p>For MP4 export to work, the page needs to be served with:<br>" +
                              "<code>Cross-Origin-Opener-Policy: same-origin</code><br>" +
                              "<code>Cross-Origin-Embedder-Policy: require-corp</code></p>" +
                              "<p>If reloading doesn't help, consider using a different browser or a hosting platform that allows setting these headers directly if MP4 export is essential.</p>";
                showModal("MP4 Export Prerequisite Missing", sabMessage);
                return false;
            }

            try {
                await initializeFFmpeg(); 
            } catch (err) {
                console.error("FFmpeg load error:", err);
                showModal("FFmpeg Load Error", "Failed to load FFmpeg components. MP4 export is unavailable. Error: " + err.message);
                loadingIndicator.classList.add('hidden');
                return false;
            }
            return true;
        }


        exportMp4Btn.addEventListener('click', async () => { 
            if (layers.every(l => !l.isVisible || l.strokes.length === 0)) { 
                showModal("Export Error", "No visible content to export."); return; 
            }

            const ffmpegReady = await checkAndLoadFFmpeg();
            if (!ffmpegReady) {
                loadingIndicator.classList.add('hidden'); 
                return; 
            }
            
            const globalExportAnimSpeedFactor = parseFloat(animationSliders.animationSpeed.slider.value);
            if (globalExportAnimSpeedFactor <= 0) {
                showModal("Export Warning", "Global Animation Speed is zero or less. The exported video will not show animation. Please increase the Animation Speed slider value if you want animated export.");
            }

            loadingIndicator.classList.remove('hidden');
            if(loadingText) loadingText.textContent = "Preparing video export...";

            const frameRate = 30; 
            const durationSeconds = 15; 
            const totalFrames = frameRate * durationSeconds;
            
            const liveAnimationTimeAtStart = time; 
            let exportRenderTime = liveAnimationTimeAtStart; 
            const timeStepPerVideoFrame = globalExportAnimSpeedFactor * (60 / frameRate);

            if (animationFrameId) cancelAnimationFrame(animationFrameId); 

            let currentFrame = 0;
            const frameFileNames = [];

            const originalCanvasWidth = canvas.width;
            const originalCanvasHeight = canvas.height;

            canvas.width = EXPORT_WIDTH;
            canvas.height = EXPORT_HEIGHT;


            async function renderAndSaveFrame() {
                if (currentFrame >= totalFrames) {
                    await compileVideo();
                    return;
                }
                if(loadingText) loadingText.textContent = `Rendering frame ${currentFrame + 1} of ${totalFrames}...`;
                
                if(canvas.width !== EXPORT_WIDTH || canvas.height !== EXPORT_HEIGHT) { 
                    canvas.width = EXPORT_WIDTH;
                    canvas.height = EXPORT_HEIGHT;
                }
                drawScene(true, exportRenderTime); 

                const frameName = `frame${String(currentFrame).padStart(4, '0')}.png`;
                frameFileNames.push(frameName);
                
                try {
                    const dataUrl = canvas.toDataURL('image/png');
                    const blob = await (await fetch(dataUrl)).blob();
                    const arrayBuffer = await blob.arrayBuffer();
                    ffmpeg.FS('writeFile', frameName, new Uint8Array(arrayBuffer));
                } catch (frameError) {
                    console.error(`Error processing frame ${frameName}:`, frameError);
                    showModal("Frame Processing Error", `Failed to process frame ${currentFrame + 1}. Export aborted.`);
                    frameFileNames.forEach(name => { try { ffmpeg.FS('unlink', name); } catch(e){} });
                    canvas.width = originalCanvasWidth; 
                    canvas.height = originalCanvasHeight;
                    loadingIndicator.classList.add('hidden');
                    time = liveAnimationTimeAtStart; 
                    animate(); 
                    return;
                }

                exportRenderTime += timeStepPerVideoFrame;
                currentFrame++;
                setTimeout(renderAndSaveFrame, 1); 
            }

            async function compileVideo() {
                if(loadingText) loadingText.textContent = "Encoding MP4... This may take a while.";
                try {
                    await ffmpeg.run('-r', String(frameRate), '-i', 'frame%04d.png', '-c:v', 'libx264', '-preset', 'medium', '-crf', '20', '-pix_fmt', 'yuv420p', 'output.mp4');
                    const data = ffmpeg.FS('readFile', 'output.mp4');
                    
                    const blob = new Blob([data.buffer], { type: 'video/mp4' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a'); a.href = url;
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-'); 
                    a.download = `drawerz_animation_${timestamp}.mp4`;
                    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                    showModal("Export Complete", "Animation exported as MP4!");

                } catch (error) {
                    console.error("FFmpeg run error:", error);
                    showModal("FFmpeg Export Error", "Error during video encoding: " + error.message);
                } finally {
                    frameFileNames.forEach(name => { try { ffmpeg.FS('unlink', name); } catch(e){} });
                    try { ffmpeg.FS('unlink', 'output.mp4'); } catch(e){}
                    
                    canvas.width = originalCanvasWidth;
                    canvas.height = originalCanvasHeight;
                    resizeCanvas(); 

                    loadingIndicator.classList.add('hidden');
                    time = liveAnimationTimeAtStart; 
                    animate(); 
                }
            }
            renderAndSaveFrame(); 
        });

        exportGifBtn.addEventListener('click', async () => {
            if (layers.every(l => !l.isVisible || l.strokes.length === 0)) {
                showModal("Export Error", "No visible content to export.");
                return;
            }
            loadingIndicator.classList.remove('hidden');
            if(loadingText) loadingText.textContent = "Preparing GIF export...";

            const frameRate = 10; 
            const durationSeconds = 15;
            const totalFrames = frameRate * durationSeconds;
            const delay = 1000 / frameRate; 

            const liveAnimationTimeAtStart = time;
            let exportRenderTime = liveAnimationTimeAtStart;
            const globalExportAnimSpeedFactor = parseFloat(animationSliders.animationSpeed.slider.value);
             if (globalExportAnimSpeedFactor <= 0) {
                showModal("Export Warning", "Global Animation Speed is zero or less. The exported GIF will not show animation. Please increase the Animation Speed slider value if you want animated export.");
            }
            const timeStepPerVideoFrame = globalExportAnimSpeedFactor * (60 / frameRate);


            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            const gif = new GIF({
                workers: 2, 
                quality: 10, 
                workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js',
                width: EXPORT_WIDTH,
                height: EXPORT_HEIGHT,
                background: '#FFF', 
                transparent: null 
            });

            const originalCanvasWidth = canvas.width;
            const originalCanvasHeight = canvas.height;
            canvas.width = EXPORT_WIDTH;
            canvas.height = EXPORT_HEIGHT;

            let currentFrame = 0;

            function addGifFrame() {
                if (currentFrame >= totalFrames) {
                    gif.render();
                    return;
                }
                if(loadingText) loadingText.textContent = `Rendering GIF frame ${currentFrame + 1} of ${totalFrames}...`;
                
                if(canvas.width !== EXPORT_WIDTH || canvas.height !== EXPORT_HEIGHT) {
                    canvas.width = EXPORT_WIDTH;
                    canvas.height = EXPORT_HEIGHT;
                }
                drawScene(true, exportRenderTime);
                gif.addFrame(canvas, { copy: true, delay: delay });

                exportRenderTime += timeStepPerVideoFrame;
                currentFrame++;
                setTimeout(addGifFrame, 10); 
            }

            gif.on('finished', function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                a.download = `drawerz_animation_${timestamp}.gif`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                canvas.width = originalCanvasWidth;
                canvas.height = originalCanvasHeight;
                resizeCanvas(); 

                loadingIndicator.classList.add('hidden');
                showModal("Export Complete", "Animation exported as GIF!");
                time = liveAnimationTimeAtStart;
                animate();
            });
            
            gif.on('progress', function(p) {
                 if(loadingText) loadingText.textContent = `Encoding GIF: ${Math.round(p * 100)}%`;
            });

            addGifFrame();
        });


        function initializeApp() {
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./sw.js', { scope: './' }) 
                    .then(registration => {
                        console.log('Drawerz Service Worker: Registered with scope:', registration.scope);
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            if (newWorker) {
                                newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'activated') {
                                    if (navigator.serviceWorker.controller) {
                                    console.log('Drawerz Service Worker: New version activated.');
                                    } else {
                                    console.log('Drawerz Service Worker: Activated for the first time. Page may need a reload for COOP/COEP headers.');
                                    if (typeof SharedArrayBuffer === 'undefined') {
                                        showModal("Service Worker Active", "The helper Service Worker is now active. Please try reloading the page if MP4 export initially fails due to missing requirements (SharedArrayBuffer).");
                                    }
                                    }
                                }
                                });
                            }
                        });
                    }).catch(error => {
                        console.error('Drawerz Service Worker: Registration failed:', error);
                    });
                    navigator.serviceWorker.addEventListener('message', event => {
                        if (event.data && event.data.type === 'SW_ACTIVATED') {
                            console.log('Drawerz Service Worker: Received SW_ACTIVATED message from SW.');
                             if (typeof SharedArrayBuffer === 'undefined') {
                                console.warn('SW activated, but SharedArrayBuffer still undefined. A page reload may be required for COOP/COEP headers to take effect.');
                            }
                        }
                    });
                    if (navigator.serviceWorker.controller && typeof SharedArrayBuffer === 'undefined') {
                        console.warn('Page is controlled by a Service Worker, but SharedArrayBuffer is undefined. Ensure SW sets COOP/COEP headers, or try a hard refresh (Ctrl+Shift+R).');
                    }
                });
            }


            loadingIndicator.classList.add('hidden'); messageModal.classList.add('hidden');
            setActiveToolButton(penToolBtn); 
            strokeSizeValue.textContent = strokeSizeSlider.value;
            if (layers.length === 0) { const initialLayer = createNewLayer(1); layers.push(initialLayer); setActiveLayer(initialLayer.id); }
            else setActiveLayer(layers.find(l => l.isActive)?.id || layers[0]?.id);
            
            setDefaultViewTransform(); 
            renderLayersList(); 
            updateAnimationSlidersForActiveLayer(); 
            updateUndoRedoButtons(); 
            resizeCanvas(); 
            animate(); 
            updateCanvasCursor();
        }
        addLayerBtn.addEventListener('click', addLayer);
        document.addEventListener('keydown', function(e) {
            const activeEl = document.activeElement;
            const isInputFocused = activeEl && (activeEl.tagName.toLowerCase() === 'input' && activeEl.type !== 'range' && activeEl.type !== 'button' && activeEl.type !== 'submit') || activeEl.tagName.toLowerCase() === 'textarea';
            if (isInputFocused) return; 
            let prevented = true; 
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') saveBtn.click();
            else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'o') document.getElementById('loadInput').click();
            else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'e') exportMp4Btn.click();
            else if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.code === 'Delete') { clearAllLayersBtn.click(); } 
            else if ((e.ctrlKey || e.metaKey) && e.code === 'Delete') { clearActiveLayerBtn.click(); } 
            else if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'z') { undoBtn.click(); }
            else if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))) { redoBtn.click(); }
            else if (e.key.toLowerCase() === 'p' && !e.ctrlKey && !e.metaKey) penToolBtn.click();
            else if (e.key.toLowerCase() === 'e' && !e.ctrlKey && !e.metaKey) eraserToolBtn.click();
            else if (e.key.toLowerCase() === 'h' && !e.ctrlKey && !e.metaKey) handToolBtn.click(); 
            else if (e.key.toLowerCase() === 'r' && !e.ctrlKey && !e.metaKey) resetViewBtn.click(); 
            else prevented = false;
            if (prevented) e.preventDefault();
        });
        initializeApp();
    </script>
</body>
</html>
