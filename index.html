<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawerz Beta 3 - Animated Sketchpad & Layering Tool</title>

    <link rel="icon" type="image/png" href="icon-logo.png">

    <meta name="description" content="Drawerz Beta 3: A creative web application for drawing, animating strokes with layers, and exporting your artwork as MP4 or GIF. Features include dynamic brushes, layer management, and various animation effects.">
    <meta name="keywords" content="drawing app, animation tool, vector graphics, layers, sketchpad, online drawing, html5 canvas, javascript animation, export mp4, export gif, Drawerz">
    <meta name="author" content="Bixrail & Your Name/Studio"> <link rel="canonical" href="https://your-drawerz-beta-3-url.com/"> <meta name="robots" content="index, follow">

    <meta property="og:title" content="Drawerz Beta 3 - Animated Sketchpad">
    <meta property="og:description" content="Create and animate drawings with layers. Export to MP4 or GIF.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://your-drawerz-beta-3-url.com/"> <meta property="og:image" content="chat-logo.png"> 
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Drawerz Beta 3">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Drawerz Beta 3 - Animated Sketchpad">
    <meta name="twitter:description" content="Create and animate drawings with layers. Export to MP4 or GIF.">
    <meta name="twitter:image" content="chat-logo.png"> 
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.0/dist/ffmpeg.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
</head>
<body class="bg-gray-900 text-white flex flex-col h-screen overflow-hidden">
    <style>
        /* Base styles */
        body, html {
            font-family: 'Montserrat', sans-serif !important; 
            overscroll-behavior: none;
            background-color: #111827; 
            color: #e5e7eb; 
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .header {
            background-color: #1f2937; padding: 0.75rem 1rem; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); 
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #374151; flex-shrink: 0; z-index: 20; 
        }
        .header-logo-link { display: inline-block; }
        .header-logo { height: 32px; width: auto; object-fit: contain; vertical-align: middle; }
        .header-buttons { display: flex; gap: 0.5rem; align-items: center; flex-wrap: nowrap; }
        .control-panel-toggle { display: none; background: none; border: none; color: #9ca3af; font-size: 1.5rem; cursor: pointer; padding: 0.5rem; }

        .main-content { display: flex; flex: 1; overflow: hidden; position: relative; }
        .canvas-container {
            flex: 1; padding: 0.5rem; display: flex; justify-content: center; align-items: center;
            background-color: #374151; overflow: auto; position: relative; touch-action: none;
        }
        #drawingCanvas {
            background-color: white; border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
            border: 1px solid #4b5563; 
        }

        .control-panel {
            width: 24rem; background-color: #111827; padding: 1rem; 
            box-shadow: -5px 0 15px -3px rgba(0, 0, 0, 0.1); 
            display: flex; flex-direction: column; gap: 1.25rem; 
            border-left: 1px solid #374151; max-height: 100%; overflow-y: auto; 
            transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out; 
            z-index: 10; font-family: 'Montserrat', sans-serif;
        }
        .section { display: flex; flex-direction: column; gap: 0.75rem; }
        .section-title {
            font-size: 1.1rem; font-weight: 600; color: #9ca3af; 
            border-bottom: 1px solid #374151; padding-bottom: 0.4rem;
            margin-bottom: 0.2rem; font-family: 'Montserrat', sans-serif;
        }
        .tools-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); gap: 0.5rem; } 

        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; 
            padding: 0.5rem 0.75rem; border-radius: 0.375rem; font-weight: 500; 
            transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.15s ease-in-out;
            cursor: pointer; border: 1px solid #4b5563; font-size: 0.8rem; 
            color: #d1d5db; background-color: #374151; white-space: nowrap; 
            font-family: 'Montserrat', sans-serif !important; 
        }
        .btn i { font-size: 0.9em; } 
        .btn:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.1); background-color: #4b5563; border-color: #6b7280; }
        .btn:active:not(:disabled) { transform: translateY(0px); box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); background-color: #2d3748; }
        .btn.active-tool, .btn.active-layer-control { background-color: #2563eb !important; color: white !important; border-color: #3b82f6 !important; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); }
        .btn.active-tool:hover, .btn.active-layer-control:hover { background-color: #1d4ed8 !important; }
        .btn-primary { background-color: #3b82f6; color: white; border-color: #3b82f6; }
        .btn-primary:hover:not(:disabled) { background-color: #2563eb; border-color: #2563eb;}
        .btn-primary:active:not(:disabled) { background-color: #1d4ed8; }
        .btn-danger { background-color: #ef4444; color: white; border-color: #ef4444; }
        .btn-danger:hover:not(:disabled) { background-color: #dc2626; border-color: #dc2626; }
        .btn-danger:active:not(:disabled) { background-color: #b91c1c; }
        .btn:disabled, .btn.btn-disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
        label.btn { display: inline-flex; }
        #loadInput { display: none; }

        .form-group { display: flex; flex-direction: column; gap: 0.4rem; }
        .form-label { font-size: 0.8rem; font-weight: 500; color: #9ca3af; }
        .form-label span { color: #e5e7eb; } 
        input[type="range"] { width: 100%; height: 0.5rem; background-color: #374151; border-radius: 9999px; appearance: none; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 1rem; height: 1rem; background: #3b82f6; border-radius: 50%; cursor: pointer; border: 2px solid white; }
        input[type="range"]::-moz-range-thumb { width: 0.8rem; height: 0.8rem; background: #3b82f6; border-radius: 50%; cursor: pointer; border: 2px solid white; }
        input[type="color"] { width: 100%; height: 2.25rem; padding: 0.125rem; background-color: #374151; border: 1px solid #4b5563; border-radius: 0.375rem; cursor: pointer; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 0.25rem; }
        input[type="color"]::-moz-color-swatch { border: none; border-radius: 0.25rem; }

        .footer { padding: 0.75rem; background-color: #1f2937; color: #6b7280; text-align: center; font-size: 0.75rem; border-top: 1px solid #374151; flex-shrink: 0; }
        .hidden { display: none !important; }
        #loadingIndicator { position: fixed; inset: 0; background-color: rgba(17, 24, 39, 0.8); display: flex; justify-content: center; align-items: center; z-index: 100; }
        .loading-content { display: flex; flex-direction: column; align-items: center; gap: 1rem; background-color: #1f2937; padding: 2rem; border-radius: 0.5rem; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); color: #e5e7eb; }
        .spinner { border: 4px solid #4b5563; border-top-color: #3b82f6; border-radius: 50%; width: 2.5rem; height: 2.5rem; animation: spin 0.8s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .modal { position: fixed; inset: 0; background-color: rgba(17, 24, 39, 0.8); display: flex; justify-content: center; align-items: center; z-index: 100; padding: 1rem; }
        .modal-content { background-color: #1f2937; color: #e5e7eb; padding: 1.5rem 2rem; border-radius: 0.5rem; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); max-width: 36rem; width: 100%; }
        .modal-title { font-size: 1.25rem; font-weight: 600; color: white; }
        .modal-message { color: #d1d5db; font-size: 0.925rem; line-height: 1.6; }
        .modal-button-container { display: flex; justify-content: flex-end; margin-top: 1rem; }
        .modal-button { background-color: #3b82f6; color: white; font-weight: 500; padding: 0.625rem 1.25rem; border-radius: 0.375rem; border: 1px solid #3b82f6; }

        .layers-list { display: flex; flex-direction: column; gap: 0.5rem; max-height: 220px; overflow-y: auto; border: 1px solid #374151; border-radius: 0.375rem; padding: 0.5rem; }
        .layer-item { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; border-radius: 0.25rem; background-color: #1f2937; border: 1px solid #374151; cursor: pointer; }
        .layer-item:hover { background-color: #2d3748; }
        .layer-item.active-layer { background-color: #3b82f6; border-color: #2563eb; color: white; }
        .layer-name { flex-grow: 1; font-size: 0.8rem; color: #d1d5db; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .layer-name-input { flex-grow: 1; font-size: 0.8rem; background-color: #374151; color: white; border: 1px solid #4b5563; border-radius: 0.25rem; padding: 0.25rem 0.5rem; }
        .layer-controls { display: flex; gap: 0.25rem; }
        .layer-controls .btn { padding: 0.25rem 0.375rem; font-size: 0.7rem; } 
        .layer-opacity-control { display: flex; flex-direction: column; gap: 0.25rem; margin-top: 0.5rem; }
        .layer-actions { display: flex; gap: 0.5rem; margin-top: 0.5rem; flex-wrap: wrap; }
        .layer-actions .btn { flex-grow: 1; min-width: 80px; } 

        ::-webkit-scrollbar { width: 0.5rem; height: 0.5rem; } 
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 0.25rem; }

        @media (max-width: 900px) { 
            .header-buttons .btn span { display: none; } 
            .header-buttons .btn i { margin-right: 0; } 
            .control-panel { position: absolute; right: 0; top: 0; bottom: 0; transform: translateX(100%); width: 280px; }
            .control-panel.open { transform: translateX(0); }
            .control-panel-toggle { display: block; }
        }
    </style>

    <header class="header">
        <a href="#" class="header-logo-link">
            <img src="head-logo.png" alt="Drawerz Beta 3 Logo" class="header-logo" onerror="this.onerror=null;this.src='https://placehold.co/200x40/3B82F6/FFFFFF?text=Drawerz&font=montserrat';">
        </a>
        <div class="header-buttons">
            <button id="saveBtn" class="btn" title="Save (Ctrl + S)"><i class="fas fa-save"></i> <span>Save</span></button>
            <label for="loadInput" class="btn" title="Load (Ctrl + O)"><i class="fas fa-folder-open"></i> <span>Load</span></label>
            <input type="file" id="loadInput" accept=".drz,.svg,.psd,.clip"> 
            <button id="exportMp4Btn" class="btn btn-primary" title="Export MP4 (Ctrl + E)"><i class="fas fa-file-video"></i> <span>Export MP4</span></button>
            <button id="exportGifBtn" class="btn btn-primary" title="Export GIF"><i class="fas fa-file-image"></i> <span>Export GIF</span></button>
            <button id="clearActiveLayerBtn" class="btn btn-danger" title="Clear Active Layer"><i class="fas fa-eraser"></i> <span>Clear Layer</span></button>
            <button id="clearAllLayersBtn" class="btn btn-danger" title="Clear All Layers (Ctrl + Shift + Delete)"><i class="fas fa-bomb"></i> <span>Clear All</span></button>
            <button id="undoBtn" class="btn" title="Undo (Ctrl + Z)"><i class="fas fa-undo"></i></button>
            <button id="redoBtn" class="btn" title="Redo (Ctrl + Y)"><i class="fas fa-redo"></i></button>
        </div>
        <button id="controlPanelToggle" class="control-panel-toggle"><i class="fas fa-bars"></i></button>
    </header>

    <div class="main-content">
        <div id="canvasContainer" class="canvas-container">
            <canvas id="drawingCanvas"></canvas> </div>

        <aside id="controlPanel" class="control-panel">
            <div class="section">
                <h2 class="section-title">Drawing Tools</h2>
                <div class="tools-grid">
                    <button id="penTool" class="btn active-tool" title="Pen Tool (P)"><i class="fas fa-pen"></i> Pen</button>
                    <button id="eraserTool" class="btn" title="Eraser Tool (E)"><i class="fas fa-eraser"></i> Eraser</button>
                    </div>
                <div class="form-group">
                    <label for="strokeSize" class="form-label">Stroke Size: <span id="strokeSizeValue">10</span>px</label>
                    <input type="range" id="strokeSize" min="1" max="100" value="10">
                </div>
                <div class="form-group">
                    <label for="strokeColor" class="form-label">Stroke Color</label>
                    <input type="color" id="strokeColor" value="#000000">
                </div>
            </div>
            
            <div class="section" id="layersSection">
                <h2 class="section-title">Layers</h2>
                <div id="layersList" class="layers-list"></div>
                <div class="layer-actions">
                    <button id="addLayerBtn" class="btn btn-primary" title="Add New Layer"><i class="fas fa-plus-circle"></i> Add Layer</button>
                </div>
                <div id="selectedLayerOpacityControl" class="form-group hidden layer-opacity-control">
                    <label for="layerOpacity" class="form-label">Layer Opacity: <span id="layerOpacityValue">100</span>%</label>
                    <input type="range" id="layerOpacity" min="0" max="100" value="100">
                </div>
            </div>

            <div class="section">
                <h2 class="section-title">Animation Effects (Active Layer)</h2>
                <div class="form-group">
                    <label for="wiggleIntensity" class="form-label">Wiggle Intensity: <span id="wiggleIntensityValue">0</span></label>
                    <input type="range" id="wiggleIntensity" min="0" max="20" value="0" step="0.5">
                </div>
                <div class="form-group"> 
                    <label for="breathingStroke" class="form-label">Breathing Stroke: <span id="breathingStrokeValue">0</span></label>
                    <input type="range" id="breathingStroke" min="0" max="20" value="0" step="1">
                </div>
                <div class="form-group">
                    <label for="shakeIntensity" class="form-label">Shake Intensity: <span id="shakeIntensityValue">0</span></label>
                    <input type="range" id="shakeIntensity" min="0" max="10" value="0" step="0.5">
                </div>
                <div class="form-group">
                    <label for="animationSpeed" class="form-label">Animation Speed: <span id="animationSpeedValue">1</span>x</label>
                    <input type="range" id="animationSpeed" min="0.1" max="5" value="1" step="0.1">
                </div>
            </div>
        </aside>
    </div>

    <div id="messageModal" class="modal hidden">
        <div class="modal-content">
            <h2 id="modalTitle" class="modal-title">Notification</h2>
            <p id="modalMessage" class="modal-message">This is a message.</p>
            <div class="modal-button-container">
                <button id="modalCloseBtn" class="btn modal-button">Close</button>
            </div>
        </div>
    </div>

    <div id="loadingIndicator" class="loadingIndicator hidden">
        <div class="loading-content">
            <div class="spinner"></div>
            <span id="loadingText">Loading...</span> </div>
    </div>
    
    <footer class="footer">
        Credits to Bixrail
    </footer>

    <script>
        // FFmpeg.wasm setup
        const { createFFmpeg, fetchFile } = FFmpeg;
        let ffmpeg; 

        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const occlusionCanvas = document.createElement('canvas');
        const occlusionCtx = occlusionCanvas.getContext('2d');


        const penToolBtn = document.getElementById('penTool');
        const eraserToolBtn = document.getElementById('eraserTool');
        const strokeSizeSlider = document.getElementById('strokeSize');
        const strokeSizeValue = document.getElementById('strokeSizeValue');
        const strokeColorPicker = document.getElementById('strokeColor');
        const clearActiveLayerBtn = document.getElementById('clearActiveLayerBtn');
        const clearAllLayersBtn = document.getElementById('clearAllLayersBtn');
        const animationSliders = {
            wiggleIntensity: { slider: document.getElementById('wiggleIntensity'), valueEl: document.getElementById('wiggleIntensityValue'), suffix: '' },
            breathingStroke: { slider: document.getElementById('breathingStroke'), valueEl: document.getElementById('breathingStrokeValue'), suffix: '' },
            shakeIntensity: { slider: document.getElementById('shakeIntensity'), valueEl: document.getElementById('shakeIntensityValue'), suffix: '' },
            animationSpeed: { slider: document.getElementById('animationSpeed'), valueEl: document.getElementById('animationSpeedValue'), suffix: 'x' }
        };
        const saveBtn = document.getElementById('saveBtn');
        const loadInput = document.getElementById('loadInput');
        const exportMp4Btn = document.getElementById('exportMp4Btn'); 
        const exportGifBtn = document.getElementById('exportGifBtn'); 
        const loadingIndicator = document.getElementById('loadingIndicator');
        const loadingText = document.getElementById('loadingText'); 
        const messageModal = document.getElementById('messageModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const layersListContainer = document.getElementById('layersList');
        const addLayerBtn = document.getElementById('addLayerBtn');
        const selectedLayerOpacityControl = document.getElementById('selectedLayerOpacityControl');
        const layerOpacitySlider = document.getElementById('layerOpacity');
        const layerOpacityValue = document.getElementById('layerOpacityValue');
        const controlPanel = document.getElementById('controlPanel');
        const controlPanelToggle = document.getElementById('controlPanelToggle');
        const canvasContainer = document.getElementById('canvasContainer');

        let isDrawing = false;
        let currentTool = 'pen';
        let currentStrokeSize = 10;
        let currentStrokeColor = '#000000';
        let layers = [];
        let activeLayerId = null;
        let lastX, lastY;
        let animationFrameId;
        let time = 0; 
        let undoStack = [];
        let redoStack = [];

        const UNDO_LIMIT = 3; // New Undo limit

        const WORLD_WIDTH = 1920;
        const WORLD_HEIGHT = 1080;
        let viewTransform = { scale: 1, offsetX: 0, offsetY: 0 };
        const EXPORT_WIDTH = 1920; 
        const EXPORT_HEIGHT = 1080; 

        function generateLayerId() { return Date.now() + Math.random().toString(36).substr(2, 9); }
        function getActiveLayer() { return layers.find(layer => layer.id === activeLayerId); }
        function getLayerIndex(layerId) { return layers.findIndex(l => l.id === layerId); }

        function setActiveToolButton(activeBtn) {
            [penToolBtn, eraserToolBtn].forEach(btn => btn.classList.remove('active-tool'));
            if (activeBtn) activeBtn.classList.add('active-tool');
            updateCanvasCursor(); 
        }
        
        function updateCanvasCursor() {
            const size = Math.max(2, currentStrokeSize);
            let cursorSVG;
            if (currentTool === 'pen') {
                cursorSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}"><circle cx="${size/2}" cy="${size/2}" r="${size/2}" fill="rgba(0,0,0,0.5)"/></svg>`;
                canvas.style.cursor = `url('data:image/svg+xml;utf8,${encodeURIComponent(cursorSVG)}') ${size/2} ${size/2}, auto`;
            } else if (currentTool === 'eraser') {
                const outlineWidth = Math.max(1, Math.min(2, size / 10)); 
                cursorSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}"><circle cx="${size/2}" cy="${size/2}" r="${size/2 - outlineWidth/2}" fill="rgba(255,255,255,0.5)" stroke="rgba(0,0,0,0.7)" stroke-width="${outlineWidth}"/></svg>`;
                canvas.style.cursor = `url('data:image/svg+xml;utf8,${encodeURIComponent(cursorSVG)}') ${size/2} ${size/2}, auto`;
            } else {
                canvas.style.cursor = 'default';
            }
        }

        function saveStateForUndo() {
            const state = { layers: JSON.parse(JSON.stringify(layers)), activeLayerId: activeLayerId, viewTransform: { ...viewTransform } };
            undoStack.push(state);
            if (undoStack.length > UNDO_LIMIT) undoStack.shift(); // Use new limit
            redoStack = []; 
            updateUndoRedoButtons();
        }
        
        function updateUndoRedoButtons() {
            undoBtn.disabled = undoStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
            undoBtn.classList.toggle('btn-disabled', undoBtn.disabled);
            redoBtn.classList.toggle('btn-disabled', redoBtn.disabled);
        }

        function showModal(title, message, customButtons = null, isCustom = false) {
            modalTitle.textContent = title;
            modalMessage.innerHTML = message; 
            const buttonContainer = messageModal.querySelector('.modal-button-container');
            buttonContainer.innerHTML = ''; 
            if (isCustom && customButtons && customButtons.length > 0) {
                customButtons.forEach(btnConfig => {
                    const button = document.createElement('button');
                    button.textContent = btnConfig.text;
                    button.className = `btn modal-button ${btnConfig.class || 'btn-primary'}`;
                    button.onclick = btnConfig.action;
                    buttonContainer.appendChild(button);
                });
            } else {
                const closeButton = document.createElement('button');
                closeButton.className = 'btn modal-button btn-primary';
                closeButton.textContent = 'Close';
                closeButton.onclick = () => closeModal(messageModal);
                buttonContainer.appendChild(closeButton);
            }
            messageModal.classList.remove('hidden');
        }

        function closeModal(modalElement) { modalElement.classList.add('hidden'); }
        messageModal.addEventListener('click', (event) => { 
            if (event.target === messageModal || event.target.classList.contains('modal-button')) { 
                if (!event.target.classList.contains('btn-danger') && !event.target.classList.contains('btn-primary') && event.target.textContent !== 'Delete' && event.target.textContent !== 'Clear Layer' && event.target.textContent !== 'Clear All') {
                     closeModal(messageModal);
                }
            }
        });

        function setupCanvasDimensions() {
            canvas.width = WORLD_WIDTH;
            canvas.height = WORLD_HEIGHT;
            occlusionCanvas.width = WORLD_WIDTH;
            occlusionCanvas.height = WORLD_HEIGHT;
            drawScene();
        }
        
        window.addEventListener('resize', () => { drawScene(); });
        
        controlPanelToggle.addEventListener('click', () => {
            controlPanel.classList.toggle('open');
            controlPanelToggle.innerHTML = controlPanel.classList.contains('open') ? '<i class="fas fa-times"></i>' : '<i class="fas fa-bars"></i>';
        });

        if (canvasContainer) {
            canvasContainer.addEventListener('click', (event) => {
                if (controlPanel.classList.contains('open') && window.innerWidth <= 900) {
                    if (event.target === canvasContainer || event.target === canvas) {
                        controlPanel.classList.remove('open');
                        controlPanelToggle.innerHTML = '<i class="fas fa-bars"></i>';
                    }
                }
            });
        }

        function createNewLayer(nameSuffix = layers.length + 1, strokes = [], customAnimationSettings = null, isVisible = true, opacity = 1, isActive = false) {
            const defaultAnimSettings = {};
            for (const key in animationSliders) {
                defaultAnimSettings[key] = parseFloat(animationSliders[key].slider.defaultValue || animationSliders[key].slider.value);
            }
            return {
                id: generateLayerId(), name: `Layer ${nameSuffix}`, strokes: strokes,
                animationSettings: customAnimationSettings || defaultAnimSettings,
                isVisible: isVisible, opacity: opacity, isActive: isActive
            };
        }

        function addLayer() {
            saveStateForUndo();
            const newLayer = createNewLayer(layers.length + 1);
            const activeLayerIndex = getLayerIndex(activeLayerId);
            if (activeLayerIndex !== -1 && activeLayerIndex < layers.length -1) layers.splice(activeLayerIndex + 1, 0, newLayer);
            else layers.push(newLayer); 
            setActiveLayer(newLayer.id); 
            updateAnimationSlidersForActiveLayer();
        }

        function setActiveLayer(layerId) {
            const previouslyActiveLayer = getActiveLayer();
            if (previouslyActiveLayer) previouslyActiveLayer.isActive = false;
            activeLayerId = layerId;
            const currentActiveLayer = getActiveLayer();
            if (currentActiveLayer) {
                currentActiveLayer.isActive = true;
                layerOpacitySlider.value = currentActiveLayer.opacity * 100;
                layerOpacityValue.textContent = Math.round(currentActiveLayer.opacity * 100);
                selectedLayerOpacityControl.classList.remove('hidden');
            } else {
                selectedLayerOpacityControl.classList.add('hidden');
            }
            renderLayersList(); 
            updateAnimationSlidersForActiveLayer();
        }
        
        layerOpacitySlider.addEventListener('input', (e) => {
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                activeLayer.opacity = parseFloat(e.target.value) / 100;
                layerOpacityValue.textContent = e.target.value;
                drawScene(); 
            }
        });

        function renderLayersList() {
            layersListContainer.innerHTML = ''; 
            if (layers.length === 0) {
                layersListContainer.innerHTML = '<p class="text-gray-500 text-sm p-2 text-center">No layers yet.</p>';
                selectedLayerOpacityControl.classList.add('hidden'); 
                return;
            }
            [...layers].reverse().forEach((layer) => { 
                const item = document.createElement('div');
                item.className = `layer-item ${layer.id === activeLayerId ? 'active-layer' : ''}`;
                item.dataset.layerId = layer.id;
                item.onclick = () => setActiveLayer(layer.id);
                
                const visibilityBtn = document.createElement('button');
                visibilityBtn.className = 'btn btn-sm';
                visibilityBtn.innerHTML = `<i class="fas ${layer.isVisible ? 'fa-eye' : 'fa-eye-slash'}"></i>`;
                visibilityBtn.title = layer.isVisible ? "Hide Layer" : "Show Layer";
                visibilityBtn.onclick = (e) => { e.stopPropagation(); toggleLayerVisibility(layer.id); };
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'layer-name'; nameSpan.textContent = layer.name; nameSpan.title = "Double-click to Rename";
                nameSpan.ondblclick = (e) => { e.stopPropagation(); makeLayerNameEditable(layer.id, nameSpan); };
                
                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'layer-controls';
                const upBtn = document.createElement('button'); upBtn.className = 'btn btn-sm'; upBtn.innerHTML = '<i class="fas fa-arrow-up"></i>'; upBtn.title = "Move Up";
                upBtn.disabled = getLayerIndex(layer.id) === layers.length - 1; 
                upBtn.onclick = (e) => { e.stopPropagation(); moveLayer(layer.id, 'up'); };
                if(upBtn.disabled) upBtn.classList.add('btn-disabled');
                
                const downBtn = document.createElement('button'); downBtn.className = 'btn btn-sm'; downBtn.innerHTML = '<i class="fas fa-arrow-down"></i>'; downBtn.title = "Move Down";
                downBtn.disabled = getLayerIndex(layer.id) === 0; 
                downBtn.onclick = (e) => { e.stopPropagation(); moveLayer(layer.id, 'down'); };
                if(downBtn.disabled) downBtn.classList.add('btn-disabled');

                const deleteBtn = document.createElement('button'); deleteBtn.className = 'btn btn-sm btn-danger'; deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>'; deleteBtn.title = "Delete Layer";
                deleteBtn.onclick = (e) => { e.stopPropagation(); deleteLayer(layer.id); };
                controlsDiv.append(upBtn, downBtn, deleteBtn);

                item.append(visibilityBtn, nameSpan, controlsDiv);
                layersListContainer.appendChild(item);
            });
            
            const activeLayer = getActiveLayer();
            if (activeLayer) selectedLayerOpacityControl.classList.remove('hidden');
            else selectedLayerOpacityControl.classList.add('hidden');
        }
        
        function makeLayerNameEditable(layerId, nameSpan) {
            const layer = layers.find(l => l.id === layerId); if (!layer) return;
            const input = document.createElement('input'); input.type = 'text'; input.className = 'layer-name-input'; input.value = layer.name;
            nameSpan.replaceWith(input); input.focus(); input.select();
            const saveName = () => {
                saveStateForUndo(); layer.name = input.value.trim() || `Layer ${getLayerIndex(layerId) + 1}`;
                renderLayersList();
            };
            input.onblur = saveName; input.onkeydown = (e) => { if (e.key === 'Enter') input.blur(); else if (e.key === 'Escape') { input.value = layer.name; input.blur(); renderLayersList(); }};
        }

        function toggleLayerVisibility(layerId) {
            saveStateForUndo(); const layer = layers.find(l => l.id === layerId);
            if (layer) layer.isVisible = !layer.isVisible; renderLayersList(); drawScene();
        }

        function deleteLayer(layerId) {
            if (layers.length <= 1) { showModal("Action Denied", "Cannot delete the last layer."); return; }
            const layerToDelete = layers.find(l => l.id === layerId); if (!layerToDelete) return;
            showModal("Confirm Deletion", `Delete layer "${layerToDelete.name}"?`, 
            [{ text: "Delete", class: 'btn-danger', action: () => {
                saveStateForUndo(); 
                const deletedLayerIndex = getLayerIndex(layerId);
                layers = layers.filter(l => l.id !== layerId);
                if (activeLayerId === layerId) {
                    if (layers.length > 0) {
                         setActiveLayer(layers[Math.max(0, deletedLayerIndex -1)].id);
                    } else {
                        activeLayerId = null; 
                    }
                }
                renderLayersList(); drawScene(); closeModal(messageModal);
            }},{ text: "Cancel", class: 'btn', action: () => closeModal(messageModal) }], true);
        }

        function moveLayer(layerId, direction) {
            saveStateForUndo(); const index = getLayerIndex(layerId); if (index === -1) return;
            if (direction === 'up' && index < layers.length - 1) [layers[index], layers[index + 1]] = [layers[index + 1], layers[index]];
            else if (direction === 'down' && index > 0) [layers[index], layers[index - 1]] = [layers[index - 1], layers[index]];
            renderLayersList(); drawScene();
        }

        function updateAnimationSlidersForActiveLayer() {
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                for (const key in animationSliders) {
                    const setting = activeLayer.animationSettings[key];
                    if (setting !== undefined) {
                        animationSliders[key].slider.value = setting;
                        animationSliders[key].valueEl.textContent = setting + (animationSliders[key].suffix || '');
                    }
                }
            } else {
                 for (const key in animationSliders) {
                    animationSliders[key].slider.value = animationSliders[key].slider.defaultValue || 0;
                    animationSliders[key].valueEl.textContent = (animationSliders[key].slider.defaultValue || 0) + (animationSliders[key].suffix || '');
                 }
            }
        }

        Object.values(animationSliders).forEach(item => {
            item.slider.addEventListener('input', (e) => {
                const activeLayer = getActiveLayer();
                if (activeLayer) {
                    const key = Object.keys(animationSliders).find(k => animationSliders[k].slider === e.target);
                    if (key) {
                        saveStateForUndo();
                        activeLayer.animationSettings[key] = parseFloat(e.target.value);
                        item.valueEl.textContent = e.target.value + (item.suffix || '');
                    }
                }
            });
        });
        
        function getCanvasPointerPos(event) { 
            const rect = canvas.getBoundingClientRect();
            return { x: (event.clientX - rect.left), y: (event.clientY - rect.top) };
        }

        function handlePointerDown(event) {
            if (!event.isPrimary || (currentTool !== 'pen' && currentTool !== 'eraser')) return;
            if (event.pointerType === 'mouse' && event.button !== 0) return;
            const activeLayer = getActiveLayer();
            if (!activeLayer || !activeLayer.isVisible) return; 
            saveStateForUndo(); 
            isDrawing = true;
            canvas.setPointerCapture(event.pointerId);
            const { x, y } = getCanvasPointerPos(event);
            if (currentTool === 'pen') {
                activeLayer.strokes.push({
                    id: generateLayerId(), points: [{ x: x, y: y }], color: currentStrokeColor, 
                    size: currentStrokeSize, tool: currentTool, originalSize: currentStrokeSize, birthTime: time, 
                });
            }
            lastX = x; lastY = y; 
        }

        function isPointInCircle(px, py, cx, cy, radius) {
            const dx = px - cx; const dy = py - cy;
            return dx * dx + dy * dy <= radius * radius;
        }

        function handlePointerMove(event) {
            if (!isDrawing || !event.isPrimary) return;
            const activeLayer = getActiveLayer();
            if (!activeLayer || !activeLayer.isVisible) return;
            const events = (typeof event.getCoalescedEvents === 'function') ? event.getCoalescedEvents() : [event];
            for (const coalescedEvent of events) {
                const { x, y } = getCanvasPointerPos(coalescedEvent); 
                if (currentTool === 'eraser') {
                    const eraserRadiusWorld = currentStrokeSize / 2; 
                    let erasedSomething = false;
                    for (let i = activeLayer.strokes.length - 1; i >= 0; i--) {
                        const stroke = activeLayer.strokes[i];
                        if (stroke.tool === 'pen') { 
                            let hit = false;
                            for (const p of stroke.points) {
                                if (isPointInCircle(p.x, p.y, x, y, eraserRadiusWorld)) {
                                    hit = true; break;
                                }
                            }
                            if (hit) { activeLayer.strokes.splice(i, 1); erasedSomething = true; }
                        }
                    }
                    if (erasedSomething) drawScene();
                    lastX = x; lastY = y; 
                } else if (currentTool === 'pen') {
                    const currentPath = activeLayer.strokes[activeLayer.strokes.length - 1];
                    if (!currentPath || currentPath.tool !== 'pen') { isDrawing = false; return; }
                    currentPath.points.push({ x: x, y: y });
                    ctx.save();
                    ctx.globalAlpha = activeLayer.opacity; 
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.beginPath(); ctx.moveTo(lastX, lastY); ctx.lineTo(x, y);         
                    ctx.strokeStyle = currentPath.color; ctx.lineWidth = currentPath.size;
                    ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.stroke();
                    ctx.restore();
                    lastX = x; lastY = y; 
                }
            }
        }
        
        // --- Stroke Occlusion Optimization Logic ---
        function getStrokeBounds(stroke) {
            if (!stroke || stroke.points.length === 0) return null;
            let minX = stroke.points[0].x, maxX = stroke.points[0].x;
            let minY = stroke.points[0].y, maxY = stroke.points[0].y;

            for (let i = 1; i < stroke.points.length; i++) {
                minX = Math.min(minX, stroke.points[i].x);
                maxX = Math.max(maxX, stroke.points[i].x);
                minY = Math.min(minY, stroke.points[i].y);
                maxY = Math.max(maxY, stroke.points[i].y);
            }
            const buffer = stroke.size / 2 + 2; // Add buffer for stroke width
            return {
                x: minX - buffer, y: minY - buffer,
                width: (maxX - minX) + (buffer * 2),
                height: (maxY - minY) + (buffer * 2)
            };
        }

        function drawSingleStroke(ctx, stroke) {
            if (!stroke || !stroke.points || stroke.points.length < 1 || stroke.tool !== 'pen') return;
            ctx.save();
            ctx.beginPath();
            if (stroke.points.length === 1) {
                ctx.arc(stroke.points[0].x, stroke.points[0].y, stroke.size / 2, 0, Math.PI * 2);
                ctx.fillStyle = stroke.color;
                ctx.fill();
            } else {
                for (let i = 0; i < stroke.points.length; i++) {
                    const p = stroke.points[i];
                    if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
                }
                ctx.strokeStyle = stroke.color;
                ctx.lineWidth = stroke.size;
                ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                ctx.stroke();
            }
            ctx.restore();
        }

        function optimizeLayerStrokes(layer) {
            if (!layer || layer.strokes.length < 4) return; // Need at least 4 strokes to check one
            
            const newStroke = layer.strokes[layer.strokes.length - 1];
            const newStrokeBounds = getStrokeBounds(newStroke);
            if (!newStrokeBounds) return;

            const strokesToRemove = new Set();

            for (let i = 0; i < layer.strokes.length - 3; i++) {
                const oldStroke = layer.strokes[i];
                const oldStrokeBounds = getStrokeBounds(oldStroke);
                if (!oldStrokeBounds) continue;

                // Simple Bounding Box check for overlap
                if (newStrokeBounds.x < oldStrokeBounds.x + oldStrokeBounds.width &&
                    newStrokeBounds.x + newStrokeBounds.width > oldStrokeBounds.x &&
                    newStrokeBounds.y < oldStrokeBounds.y + oldStrokeBounds.height &&
                    newStrokeBounds.y + newStrokeBounds.height > oldStrokeBounds.y) {
                    
                    // Bounding boxes overlap, perform pixel check
                    occlusionCtx.clearRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
                    
                    // 1. Draw the old stroke
                    drawSingleStroke(occlusionCtx, oldStroke);
                    
                    // 2. Erase the new stroke from it
                    occlusionCtx.globalCompositeOperation = 'destination-out';
                    drawSingleStroke(occlusionCtx, newStroke);
                    occlusionCtx.globalCompositeOperation = 'source-over'; // Reset

                    // 3. Check if any pixels from the old stroke remain in its bounding box area
                    try {
                        const imgData = occlusionCtx.getImageData(
                            Math.floor(oldStrokeBounds.x), 
                            Math.floor(oldStrokeBounds.y), 
                            Math.ceil(oldStrokeBounds.width), 
                            Math.ceil(oldStrokeBounds.height)
                        );
                        
                        let isFullyOccluded = true;
                        for (let j = 0; j < imgData.data.length; j += 4) {
                            if (imgData.data[j + 3] > 0) { // Check alpha channel
                                isFullyOccluded = false;
                                break;
                            }
                        }

                        if (isFullyOccluded) {
                            strokesToRemove.add(oldStroke.id);
                        }
                    } catch (e) {
                        // This can happen with getImageData if bounds are off-canvas, though unlikely with our setup.
                        console.error("Error during stroke occlusion check:", e);
                    }
                }
            }
            
            if (strokesToRemove.size > 0) {
                console.log(`Optimizing: Removing ${strokesToRemove.size} occluded strokes.`);
                layer.strokes = layer.strokes.filter(s => !strokesToRemove.has(s.id));
                // Note: We don't save to undo here, as this is a background optimization.
                // The visual result should be identical. Undoing the new stroke will restore the old state.
            }
        }


        function handlePointerUp(event) { 
            if (!event.isPrimary) return;
            if (isDrawing) {
                const activeLayer = getActiveLayer();
                isDrawing = false;
                canvas.releasePointerCapture(event.pointerId);

                // Perform optimization after drawing is complete
                if (currentTool === 'pen' && activeLayer) {
                    optimizeLayerStrokes(activeLayer);
                }

                if(currentTool === 'eraser') { 
                    drawScene(); 
                }
            }
        }
        
        canvas.addEventListener('pointerdown', handlePointerDown);
        canvas.addEventListener('pointermove', handlePointerMove);
        canvas.addEventListener('pointerup', handlePointerUp);
        canvas.addEventListener('pointerleave', handlePointerUp);
        canvas.addEventListener('pointercancel', handlePointerUp);

        penToolBtn.addEventListener('click', () => { currentTool = 'pen'; setActiveToolButton(penToolBtn); });
        eraserToolBtn.addEventListener('click', () => { currentTool = 'eraser'; setActiveToolButton(eraserToolBtn); });
        strokeSizeSlider.addEventListener('input', (e) => { currentStrokeSize = parseInt(e.target.value); strokeSizeValue.textContent = currentStrokeSize; updateCanvasCursor(); });
        strokeColorPicker.addEventListener('input', (e) => { currentStrokeColor = e.target.value; });
        
        clearActiveLayerBtn.addEventListener('click', () => { 
            const activeLayer = getActiveLayer();
            if (!activeLayer || activeLayer.strokes.length === 0) { showModal("Clear Layer", "Active layer is already empty."); return; }
            showModal("Confirm Clear Layer", `Clear all strokes from layer "${activeLayer.name}"?`,
            [{text: "Clear Layer", class: 'btn-danger', action: () => { saveStateForUndo(); activeLayer.strokes = []; drawScene(); closeModal(messageModal); }},
             {text: "Cancel", class: 'btn', action: () => closeModal(messageModal)}], true);
        });
        
        clearAllLayersBtn.addEventListener('click', () => {
            if (layers.every(l => l.strokes.length === 0)) { showModal("Clear All Layers", "All layers are already empty."); return; }
            showModal("Confirm Clear All", "Clear strokes from ALL layers?",
            [{text: "Clear All", class: 'btn-danger', action: () => { saveStateForUndo(); layers.forEach(layer => layer.strokes = []); drawScene(); closeModal(messageModal); }},
             {text: "Cancel", class: 'btn', action: () => closeModal(messageModal)}], true);
        });

        undoBtn.addEventListener('click', () => {
            if (undoStack.length > 0) {
                redoStack.push({ layers: JSON.parse(JSON.stringify(layers)), activeLayerId: activeLayerId, viewTransform: { ...viewTransform } });
                const prevState = undoStack.pop();
                layers = prevState.layers;
                activeLayerId = prevState.activeLayerId;
                layers.forEach(l => l.isActive = (l.id === activeLayerId));
                renderLayersList(); updateAnimationSlidersForActiveLayer(); drawScene(); updateUndoRedoButtons();
            }
        });

        redoBtn.addEventListener('click', () => {
            if (redoStack.length > 0) {
                undoStack.push({ layers: JSON.parse(JSON.stringify(layers)), activeLayerId: activeLayerId, viewTransform: { ...viewTransform } });
                const nextState = redoStack.pop();
                layers = nextState.layers;
                activeLayerId = nextState.activeLayerId;
                layers.forEach(l => l.isActive = (l.id === activeLayerId));
                renderLayersList(); updateAnimationSlidersForActiveLayer(); drawScene(); updateUndoRedoButtons();
            }
        });

        function drawScene(isExporting = false, exportTimeOverride = null) {
            const currentTime = isExporting ? exportTimeOverride : time;
            const targetCtx = ctx; 
            const currentCanvasWidth = isExporting ? EXPORT_WIDTH : canvas.width;
            const currentCanvasHeight = isExporting ? EXPORT_HEIGHT : canvas.height;

            if (canvas.width !== currentCanvasWidth || canvas.height !== currentCanvasHeight) {
                canvas.width = currentCanvasWidth; canvas.height = currentCanvasHeight;
            }
            
            targetCtx.fillStyle = '#FFFFFF'; 
            targetCtx.fillRect(0, 0, currentCanvasWidth, currentCanvasHeight);

            layers.forEach(layer => {
                if (!layer.isVisible || layer.strokes.length === 0) return;
                targetCtx.save(); 
                targetCtx.globalAlpha = layer.opacity; 
                targetCtx.globalCompositeOperation = 'source-over';

                const animSettings = layer.animationSettings;
                const animSpeed = parseFloat(animSettings.animationSpeed); 
                const wiggleAmp = parseFloat(animSettings.wiggleIntensity);
                const breathAmount = parseFloat(animSettings.breathingStroke);
                const shakeAmount = parseFloat(animSettings.shakeIntensity);

                layer.strokes.forEach(stroke => {
                    if (!stroke.points || stroke.points.length < 1) return;
                    targetCtx.save(); 
                    if (shakeAmount > 0) { 
                        const shakeX = (Math.random() - 0.5) * shakeAmount * animSpeed; 
                        const shakeY = (Math.random() - 0.5) * shakeAmount * animSpeed;
                        targetCtx.translate(shakeX, shakeY);
                    }
                    let currentDynamicSize = stroke.originalSize;
                    if (breathAmount > 0) {
                        currentDynamicSize = stroke.originalSize + Math.sin(currentTime * 0.1 * animSpeed + stroke.birthTime) * breathAmount;
                        currentDynamicSize = Math.max(1, currentDynamicSize);
                    }
                    if (stroke.tool === 'pen') {
                        targetCtx.beginPath();
                        if (stroke.points.length === 1) { 
                            const p = stroke.points[0];
                            const radius = currentDynamicSize / 2;
                            targetCtx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                            targetCtx.fillStyle = stroke.color; 
                            targetCtx.fill();
                        } else { 
                            for (let i = 0; i < stroke.points.length; i++) {
                                let p = { ...stroke.points[i] }; 
                                if (wiggleAmp > 0 && i > 0) {
                                    const prevP = stroke.points[i-1]; const dx = p.x - prevP.x; const dy = p.y - prevP.y;
                                    const angle = Math.atan2(dy, dx); const normalAngle = angle + Math.PI / 2; 
                                    const wiggleOffset = Math.sin(currentTime * 0.1 * animSpeed + i * 0.5 + stroke.birthTime * 0.01) * wiggleAmp;
                                    p.x += Math.cos(normalAngle) * wiggleOffset; p.y += Math.sin(normalAngle) * wiggleOffset;
                                }
                                if (i === 0) targetCtx.moveTo(p.x, p.y); else targetCtx.lineTo(p.x, p.y);
                            }
                            targetCtx.strokeStyle = stroke.color;
                            targetCtx.lineWidth = currentDynamicSize;
                            targetCtx.lineCap = 'round'; targetCtx.lineJoin = 'round'; 
                            targetCtx.stroke();
                        }
                    }
                    targetCtx.restore(); 
                });
                targetCtx.restore(); 
            });
        }

        function animate() { time += 1; drawScene(); animationFrameId = requestAnimationFrame(animate); }
        
        saveBtn.addEventListener('click', () => {
            if (layers.length === 0 || layers.every(l => l.strokes.length === 0)) { showModal("Save Sketch", "Canvas empty."); return; }
            const dataToSave = { layers: layers, activeLayerId: activeLayerId, WORLD_WIDTH, WORLD_HEIGHT, viewTransform }; 
            const jsonData = JSON.stringify(dataToSave); const blob = new Blob([jsonData], { type: 'application/octet-stream' }); 
            const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url;
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-'); a.download = `drawerz_sketch_${timestamp}.drz`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            showModal("Save Sketch", "Sketch saved as .drz file!");
        });

        loadInput.addEventListener('change', (e) => {
            const file = e.target.files[0]; if (!file) return;
            const fileName = file.name.toLowerCase(); const fileExtension = fileName.split('.').pop();
            if (fileExtension === 'drz') {
                loadingIndicator.classList.remove('hidden'); if(loadingText) loadingText.textContent = "Loading .drz sketch...";
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (data.layers && Array.isArray(data.layers)) {
                            saveStateForUndo(); 
                            layers = data.layers.map(loadedLayer => {
                                const defaultAnim = {};
                                for (const key in animationSliders) defaultAnim[key] = parseFloat(animationSliders[key].slider.defaultValue || 0);
                                return createNewLayer( 
                                    loadedLayer.name || 'Loaded Layer',
                                    loadedLayer.strokes || [],
                                    { ...defaultAnim, ...(loadedLayer.animationSettings || {}) },
                                    loadedLayer.isVisible !== undefined ? loadedLayer.isVisible : true,
                                    loadedLayer.opacity !== undefined ? loadedLayer.opacity : 1
                                );
                            });
                            if (data.activeLayerId && layers.find(l => l.id === data.activeLayerId)) activeLayerId = data.activeLayerId;
                            else if (layers.length > 0) activeLayerId = layers[layers.length - 1].id;
                            else activeLayerId = null;
                            layers.forEach(l => l.isActive = (l.id === activeLayerId));
                            renderLayersList(); updateAnimationSlidersForActiveLayer(); setupCanvasDimensions();
                            showModal("Load Sketch", "Sketch loaded!");
                        } else showModal("Load Error", "Invalid .drz file. Missing 'layers' data.");
                    } catch (error) { console.error("Load error:", error); showModal("Load Error", "Could not load sketch. " + error.message);
                    } finally { loadingIndicator.classList.add('hidden'); loadInput.value = ''; }
                };
                reader.onerror = () => { showModal("Load Error", "Error reading file."); loadingIndicator.classList.add('hidden'); loadInput.value = ''; };
                reader.readAsText(file);
            } else if (fileExtension === 'svg') { /* ... unchanged ... */ }
        });

        function parseAndAddSVG(svgString) { /* ... unchanged ... */ }
        async function initializeFFmpeg() { /* ... unchanged ... */ }
        async function checkAndLoadFFmpeg() { /* ... unchanged ... */ return true; } 
        exportMp4Btn.addEventListener('click', async () => { /* ... unchanged ... */ });
        exportGifBtn.addEventListener('click', async () => { /* ... unchanged ... */ });


        function initializeApp() {
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./sw.js', { scope: './' }) 
                    .then(registration => { console.log('Drawerz Service Worker: Registered with scope:', registration.scope); })
                    .catch(error => { console.error('Drawerz Service Worker: Registration failed:', error); });
                });
            }
            loadingIndicator.classList.add('hidden'); messageModal.classList.add('hidden');
            setActiveToolButton(penToolBtn); 
            strokeSizeValue.textContent = strokeSizeSlider.value;
            if (layers.length === 0) { const initialLayer = createNewLayer(1); layers.push(initialLayer); setActiveLayer(initialLayer.id); }
            else setActiveLayer(layers.find(l => l.isActive)?.id || (layers.length > 0 ? layers[0].id : null) ); 
            setupCanvasDimensions();
            updateAnimationSlidersForActiveLayer(); 
            updateUndoRedoButtons(); 
            animate(); 
            updateCanvasCursor();
        }

        addLayerBtn.addEventListener('click', addLayer);
        document.addEventListener('keydown', function(e) {
            const activeEl = document.activeElement;
            const isInputFocused = (activeEl && (activeEl.tagName.toLowerCase() === 'input' && activeEl.type !== 'range') || activeEl.tagName.toLowerCase() === 'textarea');
            if (isInputFocused) return; 
            let prevented = true; 
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') saveBtn.click();
            else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'o') document.getElementById('loadInput').click();
            else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'e') exportMp4Btn.click();
            else if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.code === 'Delete') { clearAllLayersBtn.click(); } 
            else if ((e.ctrlKey || e.metaKey) && e.code === 'Delete') { clearActiveLayerBtn.click(); } 
            else if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'z') { undoBtn.click(); }
            else if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))) { redoBtn.click(); }
            else if (e.key.toLowerCase() === 'p' && !e.ctrlKey && !e.metaKey) penToolBtn.click();
            else if (e.key.toLowerCase() === 'e' && !e.ctrlKey && !e.metaKey) eraserToolBtn.click();
            else prevented = false;
            if (prevented) e.preventDefault();
        });
        initializeApp();
    </script>
</body>
</html>
