<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawerz Beta 3 - Animated Sketchpad & Layering Tool</title>

    <link rel="icon" type="image/png" href="icon-logo.png">

    <meta name="description" content="Drawerz Beta 3: A creative web application for drawing, animating strokes with layers, and exporting your artwork as MP4 or GIF. Features include dynamic brushes, layer management, blending modes, clipping masks, and various animation effects.">
    <meta name="keywords" content="drawing app, animation tool, vector graphics, layers, sketchpad, online drawing, html5 canvas, javascript animation, export mp4, export gif, blend modes, clipping mask, Drawerz">
    <meta name="author" content="Bixrail & Your Name/Studio"> <link rel="canonical" href="https://your-drawerz-beta-3-url.com/"> <meta name="robots" content="index, follow">

    <meta property="og:title" content="Drawerz Beta 3 - Animated Sketchpad with Advanced Layers">
    <meta property="og:description" content="Create and animate drawings with layers, blend modes, and clipping masks. Export to MP4 or GIF.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://your-drawerz-beta-3-url.com/"> <meta property="og:image" content="chat-logo.png"> 
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Drawerz Beta 3">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Drawerz Beta 3 - Animated Sketchpad with Advanced Layers">
    <meta name="twitter:description" content="Create and animate drawings with layers, blend modes, and clipping masks. Export to MP4 or GIF.">
    <meta name="twitter:image" content="chat-logo.png"> 
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.0/dist/ffmpeg.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
</head>
<body class="bg-gray-900 text-white flex flex-col h-screen overflow-hidden">
    <style>
        /* Base styles (mostly unchanged) */
        body, html {
            font-family: 'Montserrat', sans-serif !important; 
            overscroll-behavior: none;
            background-color: #111827; 
            color: #e5e7eb; 
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .header {
            background-color: #1f2937; 
            padding: 0.75rem 1rem; 
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); 
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #374151; 
            flex-shrink: 0; 
            z-index: 20; 
        }
        .header-logo-link { display: inline-block; }
        .header-logo { height: 32px; width: auto; object-fit: contain; vertical-align: middle; }
        .header-buttons { display: flex; gap: 0.5rem; align-items: center; flex-wrap: nowrap; }
        .control-panel-toggle { display: none; background: none; border: none; color: #9ca3af; font-size: 1.5rem; cursor: pointer; padding: 0.5rem; font-family: 'Montserrat', sans-serif; }

        .main-content { display: flex; flex: 1; overflow: hidden; position: relative; }
        .canvas-container {
            flex: 1; padding: 0.5rem; display: flex; justify-content: center; align-items: center;
            background-color: #374151; overflow: auto; position: relative; touch-action: none;
        }
        #drawingCanvas {
            background-color: white; border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
            border: 1px solid #4b5563; 
        }

        .control-panel {
            width: 24rem; background-color: #111827; padding: 1rem; 
            box-shadow: -5px 0 15px -3px rgba(0, 0, 0, 0.1); 
            display: flex; flex-direction: column; gap: 1.25rem; 
            border-left: 1px solid #374151; max-height: 100%; overflow-y: auto; 
            transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out; 
            z-index: 10; font-family: 'Montserrat', sans-serif;
        }
        .section { display: flex; flex-direction: column; gap: 0.75rem; }
        .section-title {
            font-size: 1.1rem; font-weight: 600; color: #9ca3af; 
            border-bottom: 1px solid #374151; padding-bottom: 0.4rem;
            margin-bottom: 0.2rem; font-family: 'Montserrat', sans-serif;
        }
        .tools-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); gap: 0.5rem; } 

        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; 
            padding: 0.5rem 0.75rem; border-radius: 0.375rem; font-weight: 500; 
            transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.15s ease-in-out;
            cursor: pointer; border: 1px solid #4b5563; font-size: 0.8rem; 
            color: #d1d5db; background-color: #374151; white-space: nowrap; 
            font-family: 'Montserrat', sans-serif !important; 
        }
        .btn i { font-size: 0.9em; } 
        .btn:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.1); background-color: #4b5563; border-color: #6b7280; }
        .btn:active:not(:disabled) { transform: translateY(0px); box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); background-color: #2d3748; }
        .btn.active-tool, .btn.active-layer-control { background-color: #2563eb !important; color: white !important; border-color: #3b82f6 !important; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); }
        .btn.active-tool:hover, .btn.active-layer-control:hover { background-color: #1d4ed8 !important; }
        .btn-primary { background-color: #3b82f6; color: white; border-color: #3b82f6; }
        .btn-primary:hover:not(:disabled) { background-color: #2563eb; border-color: #2563eb;}
        .btn-primary:active:not(:disabled) { background-color: #1d4ed8; }
        .btn-danger { background-color: #ef4444; color: white; border-color: #ef4444; }
        .btn-danger:hover:not(:disabled) { background-color: #dc2626; border-color: #dc2626; }
        .btn-danger:active:not(:disabled) { background-color: #b91c1c; }
        .btn:disabled, .btn.btn-disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
        label.btn { display: inline-flex; }
        #loadInput { display: none; }

        .form-group { display: flex; flex-direction: column; gap: 0.4rem; }
        .form-label { font-size: 0.8rem; font-weight: 500; color: #9ca3af; font-family: 'Montserrat', sans-serif; }
        .form-label span { color: #e5e7eb; } 
        input[type="range"] { width: 100%; height: 0.5rem; background-color: #374151; border-radius: 9999px; appearance: none; cursor: pointer; transition: background-color 0.15s ease-in-out; }
        input[type="range"]:hover { background-color: #4b5563; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 1rem; height: 1rem; background: #3b82f6; border-radius: 50%; cursor: pointer; border: 2px solid white; transition: background-color 0.15s ease-in-out, transform 0.1s ease-in-out; }
        input[type="range"]::-moz-range-thumb { width: 0.8rem; height: 0.8rem; background: #3b82f6; border-radius: 50%; cursor: pointer; border: 2px solid white; transition: background-color 0.15s ease-in-out, transform 0.1s ease-in-out; }
        input[type="range"]:hover::-webkit-slider-thumb { background: #2563eb; transform: scale(1.1); }
        input[type="range"]:hover::-moz-range-thumb { background: #2563eb; transform: scale(1.1); }
        input[type="color"] { width: 100%; height: 2.25rem; padding: 0.125rem; background-color: #374151; border: 1px solid #4b5563; border-radius: 0.375rem; cursor: pointer; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 0.25rem; }
        input[type="color"]::-moz-color-swatch { border: none; border-radius: 0.25rem; }
        
        select.form-control {
            background-color: #374151; color: #d1d5db; border: 1px solid #4b5563;
            border-radius: 0.375rem; padding: 0.5rem 0.75rem; font-size: 0.8rem;
            width: 100%; font-family: 'Montserrat', sans-serif;
        }
        select.form-control:hover { border-color: #6b7280; }
        select.form-control:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); }


        .footer { padding: 0.75rem; background-color: #1f2937; color: #6b7280; text-align: center; font-size: 0.75rem; border-top: 1px solid #374151; flex-shrink: 0; font-family: 'Montserrat', sans-serif;}
        .hidden { display: none !important; }
        #loadingIndicator { position: fixed; inset: 0; background-color: rgba(17, 24, 39, 0.8); display: flex; justify-content: center; align-items: center; z-index: 100; }
        .loading-content { display: flex; flex-direction: column; align-items: center; gap: 1rem; background-color: #1f2937; padding: 2rem; border-radius: 0.5rem; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); color: #e5e7eb; }
        .loading-content span { font-family: 'Montserrat', sans-serif; } 
        .spinner { border: 4px solid #4b5563; border-top-color: #3b82f6; border-radius: 50%; width: 2.5rem; height: 2.5rem; animation: spin 0.8s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .modal { position: fixed; inset: 0; background-color: rgba(17, 24, 39, 0.8); display: flex; justify-content: center; align-items: center; z-index: 100; padding: 1rem; }
        .modal-content { background-color: #1f2937; color: #e5e7eb; padding: 1.5rem 2rem; border-radius: 0.5rem; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); max-width: 36rem; width: 100%; text-align: left; display: flex; flex-direction: column; gap: 1rem; font-family: 'Montserrat', sans-serif;}
        .modal-title { font-size: 1.25rem; font-weight: 600; color: white; }
        .modal-message { color: #d1d5db; font-size: 0.925rem; line-height: 1.6; }
        .modal-message ul { list-style-type: disc; padding-left: 1.5rem; margin-top: 0.5rem; }
        .modal-message code { background-color: #374151; padding: 0.1em 0.4em; border-radius: 0.25rem; font-size: 0.85em; }
        .modal-button-container { display: flex; justify-content: flex-end; margin-top: 1rem; }
        .modal-button { background-color: #3b82f6; color: white; font-weight: 500; padding: 0.625rem 1.25rem; border-radius: 0.375rem; border: 1px solid #3b82f6; font-family: 'Montserrat', sans-serif !important; }
        .modal-button:hover { background-color: #2563eb; border-color: #2563eb; }

        .layers-list { display: flex; flex-direction: column; gap: 0.5rem; max-height: 220px; overflow-y: auto; border: 1px solid #374151; border-radius: 0.375rem; padding: 0.5rem; }
        .layer-item { display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: 0.5rem; padding: 0.5rem; border-radius: 0.25rem; background-color: #1f2937; border: 1px solid #374151; cursor: pointer; transition: background-color 0.15s ease, border-color 0.15s ease; }
        .layer-item:hover { background-color: #2d3748; }
        .layer-item.active-layer { background-color: #3b82f6; border-color: #2563eb; color: white; }
        .layer-item.active-layer .layer-name, .layer-item.active-layer .layer-opacity-value, .layer-item.active-layer select { color: white; }
        .layer-item.active-layer select { background-color: #2563eb; border-color: #1d4ed8; }

        .layer-item-main-controls { display: flex; align-items: center; gap: 0.5rem; }
        .layer-name { flex-grow: 1; font-size: 0.8rem; color: #d1d5db; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .layer-name-input { flex-grow: 1; font-size: 0.8rem; background-color: #374151; color: white; border: 1px solid #4b5563; border-radius: 0.25rem; padding: 0.25rem 0.5rem; font-family: 'Montserrat', sans-serif; }
        .layer-item-extra-controls { display: flex; flex-direction: column; gap: 0.3rem; grid-column: 1 / -1; margin-top: 0.3rem; padding-top: 0.3rem; border-top: 1px solid #37415133;}
        .layer-item-extra-controls .form-group { gap: 0.2rem; }
        .layer-item-extra-controls .form-label { font-size: 0.7rem; margin-bottom: 0.1rem; }
        .layer-item-extra-controls select.form-control { font-size: 0.75rem; padding: 0.25rem 0.5rem; }
        .layer-item-extra-controls .btn { font-size: 0.7rem; padding: 0.2rem 0.4rem; }
        .layer-item-extra-controls input[type="checkbox"] { width: 0.8rem; height: 0.8rem; accent-color: #3b82f6; }


        .layer-item-buttons { display: flex; gap: 0.25rem; }
        .layer-item-buttons .btn { padding: 0.25rem 0.375rem; font-size: 0.7rem; } 
        
        .layer-opacity-control { display: flex; flex-direction: column; gap: 0.25rem; margin-top: 0.5rem; }
        .layer-opacity-control input[type="range"] { height: 0.4rem; }
        .layer-opacity-control .form-label { font-size: 0.8rem; }
        .layer-actions { display: flex; gap: 0.5rem; margin-top: 0.5rem; flex-wrap: wrap; }
        .layer-actions .btn { flex-grow: 1; min-width: 80px; } 

        ::-webkit-scrollbar { width: 0.5rem; height: 0.5rem; } 
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 0.25rem; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        @media (max-width: 900px) { 
            .header-title { font-size: 1.1rem; }
            .header-buttons .btn span { display: none; } 
            .header-buttons .btn i { margin-right: 0; } 
            .header-buttons .btn { padding: 0.5rem; } 
            .control-panel { position: absolute; right: 0; top: 0; bottom: 0; transform: translateX(100%); border-left: 1px solid #374151; box-shadow: -2px 0 10px rgba(0,0,0,0.3); width: 280px; }
            .control-panel.open { transform: translateX(0); }
            .control-panel-toggle { display: block; }
        }
         @media (max-width: 480px) { 
            .header-buttons { gap: 0.25rem; }
            .header-buttons .btn { padding: 0.4rem; font-size: 0.7rem; }
            .header-buttons .btn i { font-size: 0.8em; }
            .control-panel { width: calc(100% - 40px); max-width: 280px; } 
            .section-title { font-size: 1rem; }
            .form-label { font-size: 0.75rem; }
            .layer-name, .layer-name-input { font-size: 0.75rem; }
         }
    </style>

    <header class="header">
        <a href="#" class="header-logo-link">
            <img src="head-logo.png" alt="Drawerz Beta 3 Logo" class="header-logo" onerror="this.onerror=null;this.src='https://placehold.co/200x40/3B82F6/FFFFFF?text=Drawerz&font=montserrat';">
        </a>
        <div class="header-buttons">
            <button id="saveBtn" class="btn" title="Save (Ctrl + S)"><i class="fas fa-save"></i> <span>Save</span></button>
            <label for="loadInput" class="btn" title="Load (Ctrl + O)"><i class="fas fa-folder-open"></i> <span>Load</span></label>
            <input type="file" id="loadInput" accept=".drz,.svg,.psd,.clip"> 
            <button id="exportMp4Btn" class="btn btn-primary" title="Export MP4 (Ctrl + E)"><i class="fas fa-file-video"></i> <span>Export MP4</span></button>
            <button id="exportGifBtn" class="btn btn-primary" title="Export GIF"><i class="fas fa-file-image"></i> <span>Export GIF</span></button>
            <button id="clearActiveLayerBtn" class="btn btn-danger" title="Clear Active Layer"><i class="fas fa-eraser"></i> <span>Clear Layer</span></button>
            <button id="clearAllLayersBtn" class="btn btn-danger" title="Clear All Layers (Ctrl + Shift + Delete)"><i class="fas fa-bomb"></i> <span>Clear All</span></button>
            <button id="undoBtn" class="btn" title="Undo (Ctrl + Z)"><i class="fas fa-undo"></i></button>
            <button id="redoBtn" class="btn" title="Redo (Ctrl + Y)"><i class="fas fa-redo"></i></button>
        </div>
        <button id="controlPanelToggle" class="control-panel-toggle"><i class="fas fa-bars"></i></button>
    </header>

    <div class="main-content">
        <div id="canvasContainer" class="canvas-container">
            <canvas id="drawingCanvas"></canvas> </div>

        <aside id="controlPanel" class="control-panel">
            <div class="section">
                <h2 class="section-title">Drawing Tools</h2>
                <div class="tools-grid">
                    <button id="penTool" class="btn active-tool" title="Pen Tool (P)"><i class="fas fa-pen"></i> Pen</button>
                    <button id="eraserTool" class="btn" title="Eraser Tool (E)"><i class="fas fa-eraser"></i> Eraser</button>
                    </div>
                <div class="form-group">
                    <label for="strokeSize" class="form-label">Stroke Size: <span id="strokeSizeValue">10</span>px</label>
                    <input type="range" id="strokeSize" min="1" max="100" value="10">
                </div>
                <div class="form-group">
                    <label for="strokeColor" class="form-label">Stroke Color</label>
                    <input type="color" id="strokeColor" value="#000000">
                </div>
            </div>
            
            <div class="section" id="layersSection">
                <h2 class="section-title">Layers</h2>
                <div id="layersList" class="layers-list"></div>
                <div class="layer-actions">
                    <button id="addLayerBtn" class="btn btn-primary" title="Add New Layer"><i class="fas fa-plus-circle"></i> Add Layer</button>
                    <button id="mergeDownBtn" class="btn" title="Merge Down"><i class="fas fa-layer-group"></i> Merge Down</button>
                </div>
                <div id="selectedLayerControls" class="hidden">
                    <div class="form-group layer-opacity-control">
                        <label for="layerOpacity" class="form-label">Layer Opacity: <span id="layerOpacityValue">100</span>%</label>
                        <input type="range" id="layerOpacity" min="0" max="100" value="100">
                    </div>
                    </div>
            </div>

            <div class="section">
                <h2 class="section-title">Animation Effects (Active Layer)</h2>
                <div class="form-group">
                    <label for="wiggleIntensity" class="form-label">Wiggle Intensity: <span id="wiggleIntensityValue">0</span></label>
                    <input type="range" id="wiggleIntensity" min="0" max="20" value="0" step="0.5">
                </div>
                <div class="form-group"> 
                    <label for="breathingStroke" class="form-label">Breathing Stroke: <span id="breathingStrokeValue">0</span></label>
                    <input type="range" id="breathingStroke" min="0" max="20" value="0" step="1">
                </div>
                <div class="form-group">
                    <label for="shakeIntensity" class="form-label">Shake Intensity: <span id="shakeIntensityValue">0</span></label>
                    <input type="range" id="shakeIntensity" min="0" max="10" value="0" step="0.5">
                </div>
                <div class="form-group">
                    <label for="animationSpeed" class="form-label">Animation Speed: <span id="animationSpeedValue">1</span>x</label>
                    <input type="range" id="animationSpeed" min="0.1" max="5" value="1" step="0.1">
                </div>
            </div>
        </aside>
    </div>

    <div id="messageModal" class="modal hidden">
        <div class="modal-content">
            <h2 id="modalTitle" class="modal-title">Notification</h2>
            <p id="modalMessage" class="modal-message">This is a message.</p>
            <div class="modal-button-container">
                <button id="modalCloseBtn" class="btn modal-button">Close</button>
            </div>
        </div>
    </div>

    <div id="loadingIndicator" class="loadingIndicator hidden">
        <div class="loading-content">
            <div class="spinner"></div>
            <span id="loadingText">Loading...</span> </div>
    </div>
    
    <footer class="footer">
        Created by Bixrail
    </footer>

    <script>
        // FFmpeg.wasm setup
        const { createFFmpeg, fetchFile } = FFmpeg;
        let ffmpeg; 

        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        // Offscreen canvases for compositing
        let groupCompositeCanvas = document.createElement('canvas');
        let groupCompositeCtx = groupCompositeCanvas.getContext('2d');
        let clipContentCanvas = document.createElement('canvas');
        let clipContentCtx = clipContentCanvas.getContext('2d');


        const penToolBtn = document.getElementById('penTool');
        const eraserToolBtn = document.getElementById('eraserTool');

        const strokeSizeSlider = document.getElementById('strokeSize');
        const strokeSizeValue = document.getElementById('strokeSizeValue');
        const strokeColorPicker = document.getElementById('strokeColor');
        const clearActiveLayerBtn = document.getElementById('clearActiveLayerBtn');
        const clearAllLayersBtn = document.getElementById('clearAllLayersBtn');

        const animationSliders = {
            wiggleIntensity: { slider: document.getElementById('wiggleIntensity'), valueEl: document.getElementById('wiggleIntensityValue'), suffix: '' },
            breathingStroke: { slider: document.getElementById('breathingStroke'), valueEl: document.getElementById('breathingStrokeValue'), suffix: '' },
            shakeIntensity: { slider: document.getElementById('shakeIntensity'), valueEl: document.getElementById('shakeIntensityValue'), suffix: '' },
            animationSpeed: { slider: document.getElementById('animationSpeed'), valueEl: document.getElementById('animationSpeedValue'), suffix: 'x' }
        };

        const saveBtn = document.getElementById('saveBtn');
        const loadInput = document.getElementById('loadInput');
        const exportMp4Btn = document.getElementById('exportMp4Btn'); 
        const exportGifBtn = document.getElementById('exportGifBtn'); 
        const loadingIndicator = document.getElementById('loadingIndicator');
        const loadingText = document.getElementById('loadingText'); 
        
        const messageModal = document.getElementById('messageModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');

        const layersListContainer = document.getElementById('layersList');
        const addLayerBtn = document.getElementById('addLayerBtn');
        const mergeDownBtn = document.getElementById('mergeDownBtn');
        const selectedLayerControls = document.getElementById('selectedLayerControls'); // General controls for active layer
        const layerOpacitySlider = document.getElementById('layerOpacity');
        const layerOpacityValue = document.getElementById('layerOpacityValue');
        
        const controlPanel = document.getElementById('controlPanel');
        const controlPanelToggle = document.getElementById('controlPanelToggle');
        const canvasContainer = document.getElementById('canvasContainer');

        let isDrawing = false;
        let currentTool = 'pen';
        let currentStrokeSize = 10;
        let currentStrokeColor = '#000000';
        
        let layers = [];
        let activeLayerId = null;

        let lastX, lastY;
        let animationFrameId;
        let time = 0; 
        let undoStack = [];
        let redoStack = [];

        const WORLD_WIDTH = 1920;
        const WORLD_HEIGHT = 1080;

        let viewTransform = { scale: 1, offsetX: 0, offsetY: 0 };
        
        const EXPORT_WIDTH = 1920; 
        const EXPORT_HEIGHT = 1080; 

        const BLEND_MODES = [
            { name: 'Normal', value: 'source-over' }, { name: 'Multiply', value: 'multiply' },
            { name: 'Screen', value: 'screen' }, { name: 'Overlay', value: 'overlay' },
            { name: 'Darken', value: 'darken' }, { name: 'Lighten', value: 'lighten' }, // 'lighter' is often 'Add'
            { name: 'Color Dodge', value: 'color-dodge' }, { name: 'Color Burn', value: 'color-burn' },
            { name: 'Hard Light', value: 'hard-light' }, { name: 'Soft Light', value: 'soft-light' },
            { name: 'Difference', value: 'difference' }, { name: 'Exclusion', value: 'exclusion' },
            { name: 'Hue', value: 'hue' }, { name: 'Saturation', value: 'saturation' },
            { name: 'Color', value: 'color' }, { name: 'Luminosity', value: 'luminosity' }
        ];


        function generateLayerId() { return Date.now() + Math.random().toString(36).substr(2, 9); }
        function getActiveLayer() { return layers.find(layer => layer.id === activeLayerId); }
        function getLayerIndex(layerId) { return layers.findIndex(l => l.id === layerId); }


        function setActiveToolButton(activeBtn) {
            [penToolBtn, eraserToolBtn].forEach(btn => btn.classList.remove('active-tool'));
            if (activeBtn) activeBtn.classList.add('active-tool');
            updateCanvasCursor(); 
        }
        
        function updateCanvasCursor() {
            const size = Math.max(2, currentStrokeSize);
            let cursorSVG;
            if (currentTool === 'pen') {
                cursorSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}"><circle cx="${size/2}" cy="${size/2}" r="${size/2}" fill="rgba(0,0,0,0.5)"/></svg>`;
                canvas.style.cursor = `url('data:image/svg+xml;utf8,${encodeURIComponent(cursorSVG)}') ${size/2} ${size/2}, auto`;
            } else if (currentTool === 'eraser') {
                const outlineWidth = Math.max(1, Math.min(2, size / 10)); 
                cursorSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}"><circle cx="${size/2}" cy="${size/2}" r="${size/2 - outlineWidth/2}" fill="rgba(255,255,255,0.5)" stroke="rgba(0,0,0,0.7)" stroke-width="${outlineWidth}"/></svg>`;
                canvas.style.cursor = `url('data:image/svg+xml;utf8,${encodeURIComponent(cursorSVG)}') ${size/2} ${size/2}, auto`;
            } else {
                canvas.style.cursor = 'default';
            }
        }

        function saveStateForUndo() {
            const state = { layers: JSON.parse(JSON.stringify(layers)), activeLayerId: activeLayerId, viewTransform: { ...viewTransform } };
            undoStack.push(state);
            if (undoStack.length > 30) undoStack.shift();
            redoStack = []; 
            updateUndoRedoButtons();
        }
        
        function updateUndoRedoButtons() {
            undoBtn.disabled = undoStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
            undoBtn.classList.toggle('btn-disabled', undoBtn.disabled);
            redoBtn.classList.toggle('btn-disabled', redoBtn.disabled);
        }

        function showModal(title, message, customButtons = null, isCustom = false) {
            modalTitle.textContent = title;
            modalMessage.innerHTML = message; 
            const buttonContainer = messageModal.querySelector('.modal-button-container');
            buttonContainer.innerHTML = ''; 
            if (isCustom && customButtons && customButtons.length > 0) {
                customButtons.forEach(btnConfig => {
                    const button = document.createElement('button');
                    button.textContent = btnConfig.text;
                    button.className = `btn modal-button ${btnConfig.class || 'btn-primary'}`;
                    button.onclick = btnConfig.action;
                    buttonContainer.appendChild(button);
                });
            } else {
                const closeButton = document.createElement('button');
                closeButton.className = 'btn modal-button btn-primary';
                closeButton.textContent = 'Close';
                closeButton.onclick = () => closeModal(messageModal);
                buttonContainer.appendChild(closeButton);
            }
            messageModal.classList.remove('hidden');
        }

        function closeModal(modalElement) { modalElement.classList.add('hidden'); }
        messageModal.addEventListener('click', (event) => { 
            if (event.target === messageModal || event.target.classList.contains('modal-button')) { 
                if (!event.target.classList.contains('btn-danger') && !event.target.classList.contains('btn-primary') && event.target.textContent !== 'Delete' && event.target.textContent !== 'Clear Layer' && event.target.textContent !== 'Clear All') {
                     closeModal(messageModal);
                }
            }
        });

        function setupCanvasDimensions() {
            canvas.width = WORLD_WIDTH;
            canvas.height = WORLD_HEIGHT;
            // Setup offscreen canvases too
            groupCompositeCanvas.width = WORLD_WIDTH;
            groupCompositeCanvas.height = WORLD_HEIGHT;
            clipContentCanvas.width = WORLD_WIDTH;
            clipContentCanvas.height = WORLD_HEIGHT;
            drawScene();
        }
        
        window.addEventListener('resize', () => {
            // Potentially resize offscreen canvases if main canvas could change size (not in this fixed setup)
            drawScene(); 
        });
        
        controlPanelToggle.addEventListener('click', () => {
            controlPanel.classList.toggle('open');
            controlPanelToggle.innerHTML = controlPanel.classList.contains('open') ? '<i class="fas fa-times"></i>' : '<i class="fas fa-bars"></i>';
        });

        if (canvasContainer) {
            canvasContainer.addEventListener('click', (event) => {
                if (controlPanel.classList.contains('open') && window.innerWidth <= 900) {
                    if (event.target === canvasContainer || event.target === canvas) {
                        controlPanel.classList.remove('open');
                        controlPanelToggle.innerHTML = '<i class="fas fa-bars"></i>';
                    }
                }
            });
        }

        function createNewLayer(nameSuffix = layers.length + 1, strokes = [], customAnimationSettings = null, isVisible = true, opacity = 1, isActive = false, blendMode = 'source-over', isClippingMask = false) {
            const defaultAnimSettings = {};
            for (const key in animationSliders) {
                defaultAnimSettings[key] = parseFloat(animationSliders[key].slider.defaultValue || animationSliders[key].slider.value);
            }
            return {
                id: generateLayerId(), name: `Layer ${nameSuffix}`, strokes: strokes,
                animationSettings: customAnimationSettings || defaultAnimSettings,
                isVisible: isVisible, opacity: opacity, isActive: isActive,
                blendMode: blendMode, isClippingMask: isClippingMask
            };
        }

        function addLayer() {
            saveStateForUndo();
            const newLayer = createNewLayer(layers.length + 1);
            const activeLayerIndex = getLayerIndex(activeLayerId);
            if (activeLayerIndex !== -1 && activeLayerIndex < layers.length -1) layers.splice(activeLayerIndex + 1, 0, newLayer);
            else layers.push(newLayer); 
            setActiveLayer(newLayer.id); 
            // renderLayersList is called by setActiveLayer
            updateAnimationSlidersForActiveLayer();
        }

        function setActiveLayer(layerId) {
            const previouslyActiveLayer = getActiveLayer();
            if (previouslyActiveLayer) previouslyActiveLayer.isActive = false;
            activeLayerId = layerId;
            const currentActiveLayer = getActiveLayer();
            if (currentActiveLayer) {
                currentActiveLayer.isActive = true;
                layerOpacitySlider.value = currentActiveLayer.opacity * 100;
                layerOpacityValue.textContent = Math.round(currentActiveLayer.opacity * 100);
                selectedLayerControls.classList.remove('hidden');
            } else {
                selectedLayerControls.classList.add('hidden');
            }
            renderLayersList(); 
            updateAnimationSlidersForActiveLayer();
            updateMergeDownButtonState();
        }
        
        layerOpacitySlider.addEventListener('input', (e) => {
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                activeLayer.opacity = parseFloat(e.target.value) / 100;
                layerOpacityValue.textContent = e.target.value;
                drawScene(); 
            }
        });

        function renderLayersList() {
            layersListContainer.innerHTML = ''; 
            if (layers.length === 0) {
                layersListContainer.innerHTML = '<p class="text-gray-500 text-sm p-2 text-center">No layers yet.</p>';
                selectedLayerControls.classList.add('hidden'); 
                updateMergeDownButtonState();
                return;
            }
            [...layers].reverse().forEach((layer) => { 
                const item = document.createElement('div');
                item.className = `layer-item ${layer.id === activeLayerId ? 'active-layer' : ''}`;
                item.dataset.layerId = layer.id;
                item.onclick = () => setActiveLayer(layer.id);

                // Main controls: visibility, name
                const mainControlsDiv = document.createElement('div');
                mainControlsDiv.className = 'layer-item-main-controls';
                const visibilityBtn = document.createElement('button');
                visibilityBtn.className = 'btn btn-sm';
                visibilityBtn.innerHTML = `<i class="fas ${layer.isVisible ? 'fa-eye' : 'fa-eye-slash'}"></i>`;
                visibilityBtn.title = layer.isVisible ? "Hide Layer" : "Show Layer";
                visibilityBtn.onclick = (e) => { e.stopPropagation(); toggleLayerVisibility(layer.id); };
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'layer-name'; nameSpan.textContent = layer.name; nameSpan.title = "Double-click to Rename";
                nameSpan.ondblclick = (e) => { e.stopPropagation(); makeLayerNameEditable(layer.id, nameSpan); };
                mainControlsDiv.append(visibilityBtn, nameSpan);

                // Action buttons: up, down, delete
                const actionButtonsDiv = document.createElement('div');
                actionButtonsDiv.className = 'layer-item-buttons';
                const upBtn = document.createElement('button'); upBtn.className = 'btn btn-sm'; upBtn.innerHTML = '<i class="fas fa-arrow-up"></i>'; upBtn.title = "Move Up";
                upBtn.disabled = getLayerIndex(layer.id) === layers.length - 1; 
                upBtn.onclick = (e) => { e.stopPropagation(); moveLayer(layer.id, 'up'); };
                if(upBtn.disabled) upBtn.classList.add('btn-disabled');
                
                const downBtn = document.createElement('button'); downBtn.className = 'btn btn-sm'; downBtn.innerHTML = '<i class="fas fa-arrow-down"></i>'; downBtn.title = "Move Down";
                downBtn.disabled = getLayerIndex(layer.id) === 0; 
                downBtn.onclick = (e) => { e.stopPropagation(); moveLayer(layer.id, 'down'); };
                if(downBtn.disabled) downBtn.classList.add('btn-disabled');

                const deleteBtn = document.createElement('button'); deleteBtn.className = 'btn btn-sm btn-danger'; deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>'; deleteBtn.title = "Delete Layer";
                deleteBtn.onclick = (e) => { e.stopPropagation(); deleteLayer(layer.id); };
                actionButtonsDiv.append(upBtn, downBtn, deleteBtn);

                item.append(mainControlsDiv, actionButtonsDiv); // Will adjust grid later

                // Extra controls: Blend Mode, Clipping Mask (only if active)
                if (layer.id === activeLayerId) {
                    const extraControlsDiv = document.createElement('div');
                    extraControlsDiv.className = 'layer-item-extra-controls';

                    // Blend Mode Dropdown
                    const blendGroup = document.createElement('div');
                    blendGroup.className = 'form-group';
                    const blendLabel = document.createElement('label');
                    blendLabel.className = 'form-label';
                    blendLabel.textContent = 'Blend Mode:';
                    blendLabel.htmlFor = `blendMode-${layer.id}`;
                    const blendSelect = document.createElement('select');
                    blendSelect.className = 'form-control';
                    blendSelect.id = `blendMode-${layer.id}`;
                    BLEND_MODES.forEach(mode => {
                        const option = document.createElement('option');
                        option.value = mode.value; option.textContent = mode.name;
                        if (layer.blendMode === mode.value) option.selected = true;
                        blendSelect.appendChild(option);
                    });
                    blendSelect.onchange = (e) => { e.stopPropagation(); layer.blendMode = e.target.value; drawScene(); saveStateForUndo();};
                    blendSelect.onclick = (e) => e.stopPropagation(); // Prevent layer selection change
                    blendGroup.append(blendLabel, blendSelect);
                    extraControlsDiv.appendChild(blendGroup);

                    // Clipping Mask Toggle
                    const clipGroup = document.createElement('div');
                    clipGroup.className = 'form-group flex flex-row items-center gap-2 mt-1';
                    const clipCheckbox = document.createElement('input');
                    clipCheckbox.type = 'checkbox';
                    clipCheckbox.id = `clipMask-${layer.id}`;
                    clipCheckbox.checked = layer.isClippingMask;
                    clipCheckbox.className = "form-checkbox h-4 w-4 text-blue-600 border-gray-500 rounded focus:ring-blue-500";
                    clipCheckbox.onchange = (e) => { e.stopPropagation(); layer.isClippingMask = e.target.checked; renderLayersList(); drawScene(); saveStateForUndo();}; // Re-render list for icon
                    clipCheckbox.onclick = (e) => e.stopPropagation();
                    const clipLabel = document.createElement('label');
                    clipLabel.className = 'form-label text-xs';
                    clipLabel.textContent = 'Clipping Mask';
                    clipLabel.htmlFor = `clipMask-${layer.id}`;
                    clipGroup.append(clipCheckbox, clipLabel);
                    
                    // Visual indicator for clipping mask on the layer name
                    if (layer.isClippingMask) {
                        nameSpan.innerHTML = `<i class="fas fa-caret-down fa-rotate-270 mr-1 text-xs opacity-70"></i> ${layer.name}`;
                        item.classList.add('is-clipping-mask-item'); // For potential indenting via CSS
                    }


                    extraControlsDiv.appendChild(clipGroup);
                    item.appendChild(extraControlsDiv);
                }
                layersListContainer.appendChild(item);
            });
            const activeLayer = getActiveLayer();
            if (activeLayer) selectedLayerControls.classList.remove('hidden');
            else selectedLayerControls.classList.add('hidden');
            updateMergeDownButtonState();
        }
        
        function makeLayerNameEditable(layerId, nameSpan) {
            const layer = layers.find(l => l.id === layerId); if (!layer) return;
            const input = document.createElement('input'); input.type = 'text'; input.className = 'layer-name-input'; input.value = layer.name;
            nameSpan.replaceWith(input); input.focus(); input.select();
            const saveName = () => {
                saveStateForUndo(); layer.name = input.value.trim() || `Layer ${getLayerIndex(layerId) + 1}`;
                renderLayersList(); // Re-render to update name
            };
            input.onblur = saveName; input.onkeydown = (e) => { if (e.key === 'Enter') input.blur(); else if (e.key === 'Escape') { input.value = layer.name; input.blur(); renderLayersList(); }};
        }

        function toggleLayerVisibility(layerId) {
            saveStateForUndo(); const layer = layers.find(l => l.id === layerId);
            if (layer) layer.isVisible = !layer.isVisible; renderLayersList(); drawScene();
        }

        function deleteLayer(layerId) {
            if (layers.length <= 1) { showModal("Action Denied", "Cannot delete the last layer."); return; }
            const layerToDelete = layers.find(l => l.id === layerId); if (!layerToDelete) return;
            showModal("Confirm Deletion", `Delete layer "${layerToDelete.name}"?`, 
            [{ text: "Delete", class: 'btn-danger', action: () => {
                saveStateForUndo(); 
                const deletedLayerIndex = getLayerIndex(layerId);
                layers = layers.filter(l => l.id !== layerId);
                if (activeLayerId === layerId) {
                    if (layers.length > 0) {
                         setActiveLayer(layers[Math.max(0, deletedLayerIndex -1)].id);
                    } else {
                        activeLayerId = null; // No layers left
                    }
                }
                renderLayersList(); drawScene(); closeModal(messageModal);
            }},{ text: "Cancel", class: 'btn', action: () => closeModal(messageModal) }], true);
        }

        function moveLayer(layerId, direction) {
            saveStateForUndo(); const index = getLayerIndex(layerId); if (index === -1) return;
            if (direction === 'up' && index < layers.length - 1) [layers[index], layers[index + 1]] = [layers[index + 1], layers[index]];
            else if (direction === 'down' && index > 0) [layers[index], layers[index - 1]] = [layers[index - 1], layers[index]];
            renderLayersList(); drawScene();
        }
        
        mergeDownBtn.addEventListener('click', () => {
            const activeLayer = getActiveLayer();
            if (!activeLayer) return;
            const activeIndex = getLayerIndex(activeLayerId);
            if (activeIndex === -1 || activeIndex === 0) { // Cannot merge down if it's the bottom layer or no active layer
                showModal("Merge Down", "Cannot merge down. No layer below or only one layer exists.");
                return;
            }
            const layerBelow = layers[activeIndex - 1];
            showModal("Confirm Merge Down", `Merge layer "${activeLayer.name}" down into "${layerBelow.name}"? This cannot be undone easily after other actions.`,
            [{text: "Merge", class: 'btn-primary', action: () => {
                saveStateForUndo();
                // Add strokes from active layer to layer below
                // Note: Strokes will adopt properties (animations) of the target layer.
                // Opacity/Blend mode of merged strokes will be that of the target layer.
                layerBelow.strokes.push(...activeLayer.strokes);
                
                // Remove active layer
                layers.splice(activeIndex, 1);
                
                // Set the layer below as active
                setActiveLayer(layerBelow.id);
                
                renderLayersList();
                drawScene();
                closeModal(messageModal);
                updateMergeDownButtonState();
            }}, {text: "Cancel", class: 'btn', action: () => closeModal(messageModal)}], true);
        });

        function updateMergeDownButtonState() {
            const activeIndex = getLayerIndex(activeLayerId);
            if (activeIndex !== -1 && activeIndex > 0 && layers.length > 1) {
                mergeDownBtn.disabled = false;
                mergeDownBtn.classList.remove('btn-disabled');
            } else {
                mergeDownBtn.disabled = true;
                mergeDownBtn.classList.add('btn-disabled');
            }
        }


        function updateAnimationSlidersForActiveLayer() {
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                for (const key in animationSliders) {
                    const setting = activeLayer.animationSettings[key];
                    if (setting !== undefined) {
                        animationSliders[key].slider.value = setting;
                        animationSliders[key].valueEl.textContent = setting + (animationSliders[key].suffix || '');
                    }
                }
            } else {
                 for (const key in animationSliders) {
                    animationSliders[key].slider.value = animationSliders[key].slider.defaultValue || 0;
                    animationSliders[key].valueEl.textContent = (animationSliders[key].slider.defaultValue || 0) + (animationSliders[key].suffix || '');
                 }
            }
        }

        Object.values(animationSliders).forEach(item => {
            item.slider.addEventListener('input', (e) => {
                const activeLayer = getActiveLayer();
                if (activeLayer) {
                    const key = Object.keys(animationSliders).find(k => animationSliders[k].slider === e.target);
                    if (key) {
                        saveStateForUndo(); // Save state when animation slider changes
                        activeLayer.animationSettings[key] = parseFloat(e.target.value);
                        item.valueEl.textContent = e.target.value + (item.suffix || '');
                    }
                }
            });
        });
        
        function getCanvasPointerPos(event) { 
            const rect = canvas.getBoundingClientRect();
            return { x: (event.clientX - rect.left), y: (event.clientY - rect.top) };
        }

        function handlePointerDown(event) {
            if (!event.isPrimary || (currentTool !== 'pen' && currentTool !== 'eraser')) return;
            if (event.pointerType === 'mouse' && event.button !== 0) return;
            const activeLayer = getActiveLayer();
            if (!activeLayer || !activeLayer.isVisible) return; 
            saveStateForUndo(); 
            isDrawing = true;
            canvas.setPointerCapture(event.pointerId);
            const { x, y } = getCanvasPointerPos(event);
            if (currentTool === 'pen') {
                activeLayer.strokes.push({
                    id: generateLayerId(), points: [{ x: x, y: y }], color: currentStrokeColor, 
                    size: currentStrokeSize, tool: currentTool, originalSize: currentStrokeSize, birthTime: time, 
                });
            }
            lastX = x; lastY = y; 
        }

        function isPointInCircle(px, py, cx, cy, radius) {
            const dx = px - cx; const dy = py - cy;
            return dx * dx + dy * dy <= radius * radius;
        }

        function handlePointerMove(event) {
            if (!isDrawing || !event.isPrimary) return;
            const activeLayer = getActiveLayer();
            if (!activeLayer || !activeLayer.isVisible) return;
            const events = (typeof event.getCoalescedEvents === 'function') ? event.getCoalescedEvents() : [event];
            for (const coalescedEvent of events) {
                const { x, y } = getCanvasPointerPos(coalescedEvent); 
                if (currentTool === 'eraser') {
                    const eraserRadiusWorld = currentStrokeSize / 2; 
                    let erasedSomething = false;
                    for (let i = activeLayer.strokes.length - 1; i >= 0; i--) {
                        const stroke = activeLayer.strokes[i];
                        if (stroke.tool === 'pen') { 
                            let hit = false;
                            for (const p of stroke.points) {
                                if (isPointInCircle(p.x, p.y, x, y, eraserRadiusWorld)) {
                                    hit = true; break;
                                }
                            }
                            if (hit) { activeLayer.strokes.splice(i, 1); erasedSomething = true; }
                        }
                    }
                    if (erasedSomething) drawScene();
                    lastX = x; lastY = y; 
                } else if (currentTool === 'pen') {
                    const currentPath = activeLayer.strokes[activeLayer.strokes.length - 1];
                    if (!currentPath || currentPath.tool !== 'pen') { isDrawing = false; return; }
                    currentPath.points.push({ x: x, y: y });
                    ctx.save();
                    ctx.globalAlpha = activeLayer.opacity; 
                    ctx.globalCompositeOperation = 'source-over'; // Live drawing is always source-over on top
                    ctx.beginPath(); ctx.moveTo(lastX, lastY); ctx.lineTo(x, y);         
                    ctx.strokeStyle = currentPath.color; ctx.lineWidth = currentPath.size;
                    ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.stroke();
                    ctx.restore();
                    lastX = x; lastY = y; 
                }
            }
        }

        function handlePointerUp(event) { 
            if (!event.isPrimary) return;
            if (isDrawing) {
                isDrawing = false;
                canvas.releasePointerCapture(event.pointerId);
                if(currentTool === 'eraser') { drawScene(); }
            }
        }
        
        canvas.addEventListener('pointerdown', handlePointerDown);
        canvas.addEventListener('pointermove', handlePointerMove);
        canvas.addEventListener('pointerup', handlePointerUp);
        canvas.addEventListener('pointerleave', handlePointerUp);
        canvas.addEventListener('pointercancel', handlePointerUp);

        penToolBtn.addEventListener('click', () => { currentTool = 'pen'; setActiveToolButton(penToolBtn); });
        eraserToolBtn.addEventListener('click', () => { currentTool = 'eraser'; setActiveToolButton(eraserToolBtn); });
        strokeSizeSlider.addEventListener('input', (e) => { currentStrokeSize = parseInt(e.target.value); strokeSizeValue.textContent = currentStrokeSize; updateCanvasCursor(); });
        strokeColorPicker.addEventListener('input', (e) => { currentStrokeColor = e.target.value; });
        
        clearActiveLayerBtn.addEventListener('click', () => { 
            const activeLayer = getActiveLayer();
            if (!activeLayer || activeLayer.strokes.length === 0) { showModal("Clear Layer", "Active layer is already empty."); return; }
            showModal("Confirm Clear Layer", `Clear all strokes from layer "${activeLayer.name}"?`,
            [{text: "Clear Layer", class: 'btn-danger', action: () => { saveStateForUndo(); activeLayer.strokes = []; drawScene(); closeModal(messageModal); }},
             {text: "Cancel", class: 'btn', action: () => closeModal(messageModal)}], true);
        });
        
        clearAllLayersBtn.addEventListener('click', () => {
            if (layers.every(l => l.strokes.length === 0)) { showModal("Clear All Layers", "All layers are already empty."); return; }
            showModal("Confirm Clear All", "Clear strokes from ALL layers?",
            [{text: "Clear All", class: 'btn-danger', action: () => { saveStateForUndo(); layers.forEach(layer => layer.strokes = []); drawScene(); closeModal(messageModal); }},
             {text: "Cancel", class: 'btn', action: () => closeModal(messageModal)}], true);
        });

        undoBtn.addEventListener('click', () => {
            if (undoStack.length > 0) {
                redoStack.push({ layers: JSON.parse(JSON.stringify(layers)), activeLayerId: activeLayerId, viewTransform: { ...viewTransform } });
                const prevState = undoStack.pop();
                layers = prevState.layers;
                activeLayerId = prevState.activeLayerId; // Restore active layer ID
                layers.forEach(l => l.isActive = (l.id === activeLayerId)); // Ensure isActive flags are correct
                renderLayersList(); updateAnimationSlidersForActiveLayer(); drawScene(); updateUndoRedoButtons();
            }
        });

        redoBtn.addEventListener('click', () => {
            if (redoStack.length > 0) {
                undoStack.push({ layers: JSON.parse(JSON.stringify(layers)), activeLayerId: activeLayerId, viewTransform: { ...viewTransform } });
                const nextState = redoStack.pop();
                layers = nextState.layers;
                activeLayerId = nextState.activeLayerId; // Restore active layer ID
                layers.forEach(l => l.isActive = (l.id === activeLayerId)); // Ensure isActive flags are correct
                renderLayersList(); updateAnimationSlidersForActiveLayer(); drawScene(); updateUndoRedoButtons();
            }
        });

        // Helper to draw a single layer's content to a given context
        function drawSingleLayerContentToContext(targetContext, layer, currentTime, canvasWidth, canvasHeight) {
            if (!layer.isVisible || layer.strokes.length === 0) return;

            const animSettings = layer.animationSettings;
            const animSpeed = parseFloat(animSettings.animationSpeed); 
            const wiggleAmp = parseFloat(animSettings.wiggleIntensity);
            const breathAmount = parseFloat(animSettings.breathingStroke);
            const shakeAmount = parseFloat(animSettings.shakeIntensity);

            layer.strokes.forEach(stroke => {
                if (!stroke.points || stroke.points.length < 1) return;
                targetContext.save(); 

                if (shakeAmount > 0) { 
                    const shakeX = (Math.random() - 0.5) * shakeAmount * animSpeed; 
                    const shakeY = (Math.random() - 0.5) * shakeAmount * animSpeed;
                    targetContext.translate(shakeX, shakeY);
                }

                let currentDynamicSize = stroke.originalSize;
                if (breathAmount > 0) {
                    currentDynamicSize = stroke.originalSize + Math.sin(currentTime * 0.1 * animSpeed + stroke.birthTime) * breathAmount;
                    currentDynamicSize = Math.max(1, currentDynamicSize);
                }
                
                if (stroke.tool === 'pen') {
                    targetContext.beginPath();
                    if (stroke.points.length === 1) { 
                        const p = stroke.points[0];
                        const radius = currentDynamicSize / 2;
                        targetContext.arc(p.x, p.y, radius, 0, Math.PI * 2);
                        targetContext.fillStyle = stroke.color; 
                        targetContext.fill();
                    } else { 
                        for (let i = 0; i < stroke.points.length; i++) {
                            let p = { ...stroke.points[i] }; 
                            if (wiggleAmp > 0 && i > 0) {
                                const prevP = stroke.points[i-1]; const dx = p.x - prevP.x; const dy = p.y - prevP.y;
                                const angle = Math.atan2(dy, dx); const normalAngle = angle + Math.PI / 2; 
                                const wiggleOffset = Math.sin(currentTime * 0.1 * animSpeed + i * 0.5 + stroke.birthTime * 0.01) * wiggleAmp;
                                p.x += Math.cos(normalAngle) * wiggleOffset; p.y += Math.sin(normalAngle) * wiggleOffset;
                            }
                            if (i === 0) targetContext.moveTo(p.x, p.y); else targetContext.lineTo(p.x, p.y);
                        }
                        targetContext.strokeStyle = stroke.color;
                        targetContext.lineWidth = currentDynamicSize;
                        targetContext.lineCap = 'round'; targetContext.lineJoin = 'round'; 
                        targetContext.stroke();
                    }
                }
                targetContext.restore(); 
            });
        }


        function drawScene(isExporting = false, exportTimeOverride = null) {
            const currentTime = isExporting ? exportTimeOverride : time;
            const targetCtx = ctx; 
            const currentCanvasWidth = isExporting ? EXPORT_WIDTH : canvas.width;
            const currentCanvasHeight = isExporting ? EXPORT_HEIGHT : canvas.height;

            // Ensure main canvas and offscreen canvases are correct size for current operation
            if (canvas.width !== currentCanvasWidth || canvas.height !== currentCanvasHeight) {
                canvas.width = currentCanvasWidth; canvas.height = currentCanvasHeight;
            }
            if (groupCompositeCanvas.width !== currentCanvasWidth || groupCompositeCanvas.height !== currentCanvasHeight) {
                groupCompositeCanvas.width = currentCanvasWidth; groupCompositeCanvas.height = currentCanvasHeight;
            }
            if (clipContentCanvas.width !== currentCanvasWidth || clipContentCanvas.height !== currentCanvasHeight) {
                clipContentCanvas.width = currentCanvasWidth; clipContentCanvas.height = currentCanvasHeight;
            }
            
            targetCtx.fillStyle = '#FFFFFF'; 
            targetCtx.fillRect(0, 0, currentCanvasWidth, currentCanvasHeight);
            targetCtx.globalAlpha = 1.0;
            targetCtx.globalCompositeOperation = 'source-over';


            for (let i = 0; i < layers.length; i++) {
                const baseLayer = layers[i];
                if (!baseLayer.isVisible) continue;

                // If this layer is a clipping mask, it's handled by its base. Skip.
                if (baseLayer.isClippingMask && i > 0) {
                     // Check if the layer it's trying to clip to is visible.
                     // If the base of a clipping mask is invisible, the clipping mask also doesn't render.
                     const potentialBase = layers[i-1];
                     if (!potentialBase || !potentialBase.isVisible) continue;
                }


                // Prepare the group composite canvas for this base layer and its clippers
                groupCompositeCtx.clearRect(0, 0, currentCanvasWidth, currentCanvasHeight);
                
                // 1. Draw the base layer to the group composite canvas
                groupCompositeCtx.globalAlpha = baseLayer.opacity;
                drawSingleLayerContentToContext(groupCompositeCtx, baseLayer, currentTime, currentCanvasWidth, currentCanvasHeight);
                groupCompositeCtx.globalAlpha = 1.0; // Reset alpha for internal group compositing

                // 2. Process subsequent layers that clip to this baseLayer
                let currentCompositeLayer = baseLayer; // The layer whose blend mode will be used for the next drawImage on main canvas
                let k = i + 1;
                while (k < layers.length && layers[k].isClippingMask && layers[k].isVisible) {
                    const clippingLayer = layers[k];
                    
                    // A. Draw the clipping layer's own content (with its opacity) to a fresh temp canvas
                    clipContentCtx.clearRect(0, 0, currentCanvasWidth, currentCanvasHeight);
                    clipContentCtx.globalAlpha = clippingLayer.opacity;
                    drawSingleLayerContentToContext(clipContentCtx, clippingLayer, currentTime, currentCanvasWidth, currentCanvasHeight);
                    clipContentCtx.globalAlpha = 1.0;

                    // B. Apply the clip: Use the current groupCompositeCanvas (which has the base/accumulated group) as the mask
                    clipContentCtx.globalCompositeOperation = 'destination-in';
                    clipContentCtx.drawImage(groupCompositeCanvas, 0, 0); 
                    
                    // C. Blend this (now clipped) content onto the groupCompositeCanvas
                    // using the *clipping layer's* blend mode.
                    groupCompositeCtx.globalCompositeOperation = clippingLayer.blendMode;
                    groupCompositeCtx.drawImage(clipContentCanvas, 0, 0);
                    groupCompositeCtx.globalCompositeOperation = 'source-over'; // Reset for next potential clipper in this group

                    currentCompositeLayer = clippingLayer; // The last processed layer in the group determines the final blend for the group if needed
                    k++;
                }

                // 3. Composite the entire group (base + its clipped children) onto the main canvas
                // using the base layer's blend mode and opacity.
                targetCtx.globalAlpha = baseLayer.opacity; // Base layer's opacity for the whole group
                targetCtx.globalCompositeOperation = baseLayer.blendMode; // Base layer's blend mode for the whole group
                targetCtx.drawImage(groupCompositeCanvas, 0, 0);
                
                i = k - 1; // Advance main loop counter past processed clipped layers
            }
            // Reset main context properties
            targetCtx.globalAlpha = 1.0;
            targetCtx.globalCompositeOperation = 'source-over';
        }


        function animate() { time += 1; drawScene(); animationFrameId = requestAnimationFrame(animate); }
        
        saveBtn.addEventListener('click', () => {
            if (layers.length === 0 || layers.every(l => l.strokes.length === 0)) { showModal("Save Sketch", "Canvas empty."); return; }
            const dataToSave = { layers: layers, activeLayerId: activeLayerId, WORLD_WIDTH, WORLD_HEIGHT, viewTransform }; 
            const jsonData = JSON.stringify(dataToSave); const blob = new Blob([jsonData], { type: 'application/octet-stream' }); 
            const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url;
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-'); a.download = `drawerz_sketch_${timestamp}.drz`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            showModal("Save Sketch", "Sketch saved as .drz file!");
        });

        loadInput.addEventListener('change', (e) => {
            const file = e.target.files[0]; if (!file) return;
            const fileName = file.name.toLowerCase(); const fileExtension = fileName.split('.').pop();
            if (fileExtension === 'drz') {
                loadingIndicator.classList.remove('hidden'); if(loadingText) loadingText.textContent = "Loading .drz sketch...";
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (data.layers && Array.isArray(data.layers)) {
                            saveStateForUndo(); 
                            layers = data.layers.map(loadedLayer => {
                                const defaultAnim = {};
                                for (const key in animationSliders) defaultAnim[key] = parseFloat(animationSliders[key].slider.defaultValue || 0);
                                return {
                                    id: loadedLayer.id || generateLayerId(), name: loadedLayer.name || 'Loaded Layer',
                                    strokes: loadedLayer.strokes || [],
                                    animationSettings: { ...defaultAnim, ...(loadedLayer.animationSettings || {}) }, 
                                    isVisible: loadedLayer.isVisible !== undefined ? loadedLayer.isVisible : true,
                                    opacity: loadedLayer.opacity !== undefined ? loadedLayer.opacity : 1, isActive: false,
                                    blendMode: loadedLayer.blendMode || 'source-over',
                                    isClippingMask: loadedLayer.isClippingMask || false
                                };
                            });
                            if (data.activeLayerId && layers.find(l => l.id === data.activeLayerId)) activeLayerId = data.activeLayerId;
                            else if (layers.length > 0) activeLayerId = layers[layers.length - 1].id;
                            else activeLayerId = null;
                            layers.forEach(l => l.isActive = (l.id === activeLayerId));
                            renderLayersList(); updateAnimationSlidersForActiveLayer(); setupCanvasDimensions();
                            showModal("Load Sketch", "Sketch loaded!");
                        } else showModal("Load Error", "Invalid .drz file. Missing 'layers' data.");
                    } catch (error) { console.error("Load error:", error); showModal("Load Error", "Could not load sketch. " + error.message);
                    } finally { loadingIndicator.classList.add('hidden'); loadInput.value = ''; }
                };
                reader.onerror = () => { showModal("Load Error", "Error reading file."); loadingIndicator.classList.add('hidden'); loadInput.value = ''; };
                reader.readAsText(file);
            } else if (fileExtension === 'svg') {
                loadingIndicator.classList.remove('hidden'); if(loadingText) loadingText.textContent = "Parsing SVG...";
                const reader = new FileReader();
                reader.onload = (event) => {
                    try { parseAndAddSVG(event.target.result); showModal("SVG Import", "SVG content imported to active layer.");
                    } catch (error) { console.error("SVG Parse error:", error); showModal("SVG Import Error", "Could not parse SVG. " + error.message);
                    } finally { loadingIndicator.classList.add('hidden'); loadInput.value = ''; }
                };
                reader.onerror = () => { showModal("Load Error", "Error reading SVG file."); loadingIndicator.classList.add('hidden'); loadInput.value = ''; };
                reader.readAsText(file);
            } else if (fileExtension === 'psd' || fileExtension === 'clip') { 
                 showModal("Import Not Supported", `Direct import of <strong>.${fileExtension.toUpperCase()}</strong> files is not supported. Please export as SVG.`);
                loadInput.value = ''; 
            } else { showModal("Unsupported File", "Please load a .drz or .svg file."); loadInput.value = ''; }
        });

        function parseAndAddSVG(svgString) { /* ... SVG parsing logic (unchanged) ... */ }
        async function initializeFFmpeg() { /* ... FFmpeg init (unchanged) ... */ }
        async function checkAndLoadFFmpeg() { /* ... FFmpeg check (unchanged) ... */ return true; } // Simplified for brevity
        exportMp4Btn.addEventListener('click', async () => { /* ... MP4 export (unchanged) ... */ });
        exportGifBtn.addEventListener('click', async () => { /* ... GIF export (unchanged) ... */ });
        
        // --- (The rest of parseAndAddSVG, FFmpeg, export functions are long and mostly unchanged, so omitted for brevity here but are in the full code) ---
        // Make sure to copy the full SVG parsing, FFmpeg, and export functions from the previous version if running this.
        // For this example, I'll stub them to keep focus on layer features.
        function parseAndAddSVG(svgString) { console.log("SVG parsing called but stubbed for this example."); }
        // async function initializeFFmpeg() { console.log("FFmpeg init stubbed."); } // Already defined
        // async function checkAndLoadFFmpeg() { console.log("FFmpeg check stubbed."); return true; } // Already defined
        exportMp4Btn.addEventListener('click', async () => { showModal("Export MP4", "MP4 export function called (stubbed for this example)."); });
        exportGifBtn.addEventListener('click', async () => { showModal("Export GIF", "GIF export function called (stubbed for this example)."); });


        function initializeApp() {
            if ('serviceWorker' in navigator) { /* ... Service Worker (unchanged) ... */ }
            loadingIndicator.classList.add('hidden'); messageModal.classList.add('hidden');
            setActiveToolButton(penToolBtn); 
            strokeSizeValue.textContent = strokeSizeSlider.value;
            if (layers.length === 0) { const initialLayer = createNewLayer(1); layers.push(initialLayer); setActiveLayer(initialLayer.id); }
            else setActiveLayer(layers.find(l => l.isActive)?.id || (layers.length > 0 ? layers[0].id : null) ); 
            setupCanvasDimensions();
            updateAnimationSlidersForActiveLayer(); 
            updateUndoRedoButtons(); 
            animate(); 
            updateCanvasCursor();
            updateMergeDownButtonState(); // Initial state for merge button
        }
        addLayerBtn.addEventListener('click', addLayer);
        document.addEventListener('keydown', function(e) {
            const activeEl = document.activeElement;
            const isInputFocused = (activeEl && (activeEl.tagName.toLowerCase() === 'input' && activeEl.type !== 'range' && activeEl.type !== 'button' && activeEl.type !== 'submit') || activeEl.tagName.toLowerCase() === 'textarea' || activeEl.tagName.toLowerCase() === 'select');
            if (isInputFocused) return; 
            let prevented = true; 
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') saveBtn.click();
            else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'o') document.getElementById('loadInput').click();
            else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'e') exportMp4Btn.click();
            else if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.code === 'Delete') { clearAllLayersBtn.click(); } 
            else if ((e.ctrlKey || e.metaKey) && e.code === 'Delete') { clearActiveLayerBtn.click(); } 
            else if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'z') { undoBtn.click(); }
            else if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))) { redoBtn.click(); }
            else if (e.key.toLowerCase() === 'p' && !e.ctrlKey && !e.metaKey) penToolBtn.click();
            else if (e.key.toLowerCase() === 'e' && !e.ctrlKey && !e.metaKey) eraserToolBtn.click();
            else prevented = false;
            if (prevented) e.preventDefault();
        });
        initializeApp();
    </script>
</body>
</html>
